// Licensed under the Apache-2.0 license

use crate::{DynError, PROJECT_ROOT};
use proc_macro2::{Ident, Literal, TokenStream};
use quote::{format_ident, quote};
use registers_generator::{
    camel_case, has_single_32_bit_field, hex_const, snake_case, Register, RegisterBlock,
    RegisterBlockInstance, RegisterWidth, ValidatedRegisterBlock,
};
use registers_systemrdl::ParentScope;
use std::collections::{HashMap, HashSet};
use std::fmt::Write;
use std::io::Write as _;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::process::Stdio;
use std::rc::Rc;
use std::str::FromStr;
use std::sync::LazyLock;

static HEADER_PREFIX: &str = r"/*
Licensed under the Apache-2.0 license.
";

static HEADER_SUFFIX: &str = r"
*/
";

static SKIP_TYPES: LazyLock<HashSet<&str>> = LazyLock::new(|| HashSet::from([]));

pub(crate) fn autogen(
    check: bool,
    extra_files: &[PathBuf],
    extra_addrmap: &[String],
) -> Result<(), DynError> {
    let sub_dir = &PROJECT_ROOT.join("hw").join("caliptra-ss").to_path_buf();
    let registers_dest_dir = &PROJECT_ROOT
        .join("registers")
        .join("generated-firmware")
        .join("src")
        .to_path_buf();
    let bus_dest_dir = &PROJECT_ROOT
        .join("registers")
        .join("generated-emulator")
        .join("src")
        .to_path_buf();

    // TODO: the parsing is too fragile and requires the files to be passed in in a specific order
    let rdl_files = [
        "hw/caliptra-ss/third_party/caliptra-rtl/src/soc_ifc/rtl/mbox_csr.rdl",
        "hw/caliptra-ss/third_party/caliptra-rtl/src/soc_ifc/rtl/sha512_acc_csr.rdl",
        "hw/caliptra-ss/third_party/caliptra-rtl/src/soc_ifc/rtl/soc_ifc_reg.rdl",
        "hw/caliptra-ss/third_party/i3c-core/src/rdl/registers.rdl",
        "hw/caliptra-ss/src/integration/rtl/soc_address_map.rdl",
        "hw/el2_pic_ctrl.rdl",
        "hw/flash_ctrl.rdl",
    ];
    let mut rdl_files: Vec<PathBuf> = rdl_files.iter().map(|s| PROJECT_ROOT.join(s)).collect();
    rdl_files.extend_from_slice(extra_files);

    let mut temp_rdl = tempfile::NamedTempFile::new()?;
    if !extra_addrmap.is_empty() {
        let mut map = String::new();
        map += "addrmap extra {\n";
        for s in extra_addrmap.iter() {
            if let Some(eq) = s.find("@") {
                let typ = s[..eq].trim();
                let addr = s[eq + 1..].trim();
                map += &format!("{} {} @ {};\n", typ, typ, addr);
            } else {
                return Err(format!(
                    "Invalid addrmap entry: {} (should be in the form type@address)",
                    s
                )
                .into());
            };
        }
        map += "};\n";
        write!(temp_rdl, "{}", map)?;
        temp_rdl.flush()?;
        rdl_files.push(temp_rdl.path().to_path_buf());
    }

    // eliminate duplicate type names
    let patches = vec![
        (
            PROJECT_ROOT.join(
                "hw/caliptra-ss/third_party/i3c-core/src/rdl/target_transaction_interface.rdl",
            ),
            "QUEUE_THLD_CTRL",
            "TTI_QUEUE_THLD_CTRL",
        ),
        (
            PROJECT_ROOT.join(
                "hw/caliptra-ss/third_party/i3c-core/src/rdl/target_transaction_interface.rdl",
            ),
            "QUEUE_SIZE",
            "TTI_QUEUE_SIZE",
        ),
        (
            PROJECT_ROOT.join(
                "hw/caliptra-ss/third_party/i3c-core/src/rdl/target_transaction_interface.rdl",
            ),
            "IBI_PORT",
            "TTI_IBI_PORT",
        ),
        (
            PROJECT_ROOT.join(
                "hw/caliptra-ss/third_party/i3c-core/src/rdl/target_transaction_interface.rdl",
            ),
            "DATA_BUFFER_THLD_CTRL",
            "TTI_DATA_BUFFER_THLD_CTRL",
        ),
        (
            PROJECT_ROOT.join(
                "hw/caliptra-ss/third_party/i3c-core/src/rdl/target_transaction_interface.rdl",
            ),
            "RESET_CONTROL",
            "TTI_RESET_CONTROL",
        ),
    ];

    for rdl in rdl_files.iter() {
        if !rdl.exists() {
            return Err(format!("RDL file not found: {:?} -- ensure that you have run `git submodule init` and `git submodule update --recursive`", rdl).into());
        }
    }

    let sub_commit_id = run_cmd_stdout(
        Command::new("git")
            .current_dir(sub_dir)
            .arg("rev-parse")
            .arg("HEAD"),
        None,
    )?;
    let sub_git_status = run_cmd_stdout(
        Command::new("git")
            .current_dir(sub_dir)
            .arg("status")
            .arg("--porcelain"),
        None,
    )?;

    let mut header = HEADER_PREFIX.to_string();
    write!(
        &mut header,
        "\n generated by registers_generator with caliptra-ss repo at {sub_commit_id}",
    )?;
    if !sub_git_status.is_empty() {
        write!(
            &mut header,
            "\n\nWarning: caliptra-ss was dirty:{sub_git_status}"
        )?;
    }
    if (!extra_addrmap.is_empty()) || (!extra_files.is_empty()) {
        write!(
            &mut header,
            "\n\nWarning: processed using extra RDL files and addrmap entries: {:?}, {:?}\n",
            extra_files, extra_addrmap
        )?;
    }
    header.push_str(HEADER_SUFFIX);

    let file_source = registers_systemrdl::FsFileSource::new();
    for patch in patches {
        file_source.add_patch(&patch.0, patch.1, patch.2);
    }
    let scope = registers_systemrdl::Scope::parse_root(&file_source, &rdl_files)
        .map_err(|s| s.to_string())?;
    let scope = scope.as_parent();

    let addrmap = scope.lookup_typedef("soc").unwrap();
    let addrmap2 = scope.lookup_typedef("el2_pic").unwrap();
    let addrmap3 = scope.lookup_typedef("flashctrl_dummy").unwrap();
    let mut scopes = vec![addrmap, addrmap2, addrmap3];
    if !extra_addrmap.is_empty() {
        let addrmap3 = scope.lookup_typedef("extra").unwrap();
        scopes.push(addrmap3);
    }

    // These are types like kv_read_ctrl_reg that are used by multiple crates
    let root_block = RegisterBlock {
        declared_register_types: registers_generator::translate_types(scope)?,
        ..Default::default()
    };
    let root_block = root_block.validate_and_dedup()?;

    let mut register_types_to_crates = HashMap::new();

    generate_fw_registers(
        check,
        root_block.clone(),
        &scopes.clone(),
        header.clone(),
        registers_dest_dir,
        &mut register_types_to_crates,
    )?;
    generate_emulator_types(
        check,
        &scopes,
        bus_dest_dir,
        header.clone(),
        &register_types_to_crates,
    )
}

/// Generate types used by the emulator.
fn generate_emulator_types(
    check: bool,
    scopes: &[ParentScope],
    dest_dir: &Path,
    header: String,
    register_types_to_crates: &HashMap<String, String>,
) -> Result<(), DynError> {
    let file_action = if check {
        file_check_contents
    } else {
        delete_rust_files(dest_dir)?;
        write_file
    };
    let mut lib_code = TokenStream::new();
    let mut blocks = vec![];
    for scope in scopes.iter() {
        blocks.extend(registers_generator::translate_addrmap(*scope)?);
    }
    let mut validated_blocks = vec![];

    for block in blocks.iter_mut() {
        if block.name.ends_with("_reg") || block.name.ends_with("_csr") {
            block.name = block.name[0..block.name.len() - 4].to_string();
        }
        if block.name.ends_with("_ctrl") {
            block.name = block.name[0..block.name.len() - 5].to_string();
        }
        if block.name.ends_with("_ifc") {
            block.name = block.name[0..block.name.len() - 4].to_string();
        }
        if block.name == "I3CCSR" {
            block.name = "i3c".to_string();
        }
        if SKIP_TYPES.contains(block.name.as_str()) {
            continue;
        }
        remove_reg_prefixes(
            &mut block.registers,
            &format!("{}_", block.name.to_ascii_lowercase()),
        );
        let block = block.clone().validate_and_dedup()?;
        validated_blocks.push(block);
    }

    for block in validated_blocks.iter() {
        let rblock = block.block();
        let mut code = TokenStream::new();
        code.extend(quote! {
            #[allow(unused_imports)]
            use tock_registers::interfaces::{Readable, Writeable};
        });
        //code.extend(emu_make_data_types(block)?);
        code.extend(emu_make_peripheral_trait(
            rblock.clone(),
            register_types_to_crates,
        )?);
        code.extend(emu_make_peripheral_bus_impl(rblock.clone())?);

        let dest_file = dest_dir.join(format!("{}.rs", rblock.name));
        file_action(&dest_file, &rustfmt(&(header.clone() + &code.to_string()))?)?;
        let block_name = format_ident!("{}", rblock.name);
        lib_code.extend(quote! {
            pub mod #block_name;
        });
    }
    let root_bus_code = emu_make_root_bus(
        validated_blocks
            .iter()
            .filter(|b| !SKIP_TYPES.contains(b.block().name.as_str())),
    )?;
    let root_bus_file = dest_dir.join("root_bus.rs");
    file_action(
        &root_bus_file,
        &rustfmt(&(header.clone() + &root_bus_code.to_string()))?,
    )?;

    lib_code.extend(quote! { pub mod root_bus; });

    let lib_file = dest_dir.join("lib.rs");
    file_action(
        &lib_file,
        &rustfmt(&(header.clone() + &lib_code.to_string()))?,
    )?;
    Ok(())
}

/// Collect all registers from the block and all subblocks, also returning the subblock name
/// and starting offset for the subblock that contains the register.
fn flatten_registers(
    offset: u64,
    block_base_name: String,
    block: &RegisterBlock,
) -> Vec<(u64, String, Rc<Register>)> {
    let mut registers: Vec<(u64, String, Rc<Register>)> = block
        .registers
        .clone()
        .into_iter()
        .map(|r| (offset, block_base_name.clone(), r))
        .collect();
    block.sub_blocks.iter().for_each(|sb| {
        let new_name = if block_base_name.is_empty() {
            sb.block().name.clone()
        } else {
            format!("{}_{}", block_base_name, sb.block().name)
        };
        registers.extend(flatten_registers(
            offset + sb.start_offset(),
            new_name,
            sb.block(),
        ));
    });
    registers
}

/// Make a peripheral trait that the emulator code can implement.
fn emu_make_peripheral_trait(
    block: RegisterBlock,
    register_types_to_crates: &HashMap<String, String>,
) -> Result<TokenStream, DynError> {
    let base = camel_ident(block.name.as_str());
    let periph = format_ident!("{}Peripheral", base);
    let mut fn_tokens = TokenStream::new();

    let registers = flatten_registers(0, String::new(), &block);
    registers.iter().for_each(|(_, base_name, r)| {
        // skip as this register is not defined yet
        if r.name == "MCU_CLK_GATING_EN" {
            return;
        }
        // skip these are they are just for discovery
        if r.name == "TERMINATION_EXTCAP_HEADER" {
            return;
        }
        let ty = r.ty.as_ref().clone();
        let base_field = snake_ident(r.name.as_str());
        let base_name = if base_name.is_empty() {
            base_name.clone()
        } else {
            format!("{}_", snake_ident(base_name.as_str()))
        };
        let read_name = format_ident!(
            "{}",
            format!("read_{}{}", base_name, base_field).replace("__", "_")
        );
        let write_name = format_ident!(
            "{}",
            format!("write_{}{}", base_name, base_field).replace("__", "_"),
        );
        if has_single_32_bit_field(&r.ty) {
            fn_tokens.extend(quote! {
                fn #read_name(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData { 0 }
                fn #write_name(&mut self, _size: emulator_types::RvSize, _val: emulator_types::RvData) {}
            });
        } else {
            let rcrate = format_ident!(
                "{}",
                register_types_to_crates
                    .get(ty.name.as_ref().unwrap())
                    .unwrap()
            );
            let tyn = camel_ident(ty.name.as_ref().unwrap());
            let read_val = quote! { registers_generated :: #rcrate :: bits :: #tyn :: Register };
            let prim = format_ident!("{}", ty.width.rust_primitive_name());
            let fulltyn = quote! { emulator_bus::ReadWriteRegister::<#prim, #read_val> };
            fn_tokens.extend(quote! {
                fn #read_name(&mut self, _size: emulator_types::RvSize) -> #fulltyn {
                    emulator_bus::ReadWriteRegister :: new(0)
                }
                fn #write_name(&mut self, _size: emulator_types::RvSize, _val: #fulltyn) {}
            });
        }
    });
    let mut tokens = TokenStream::new();
    tokens.extend(quote! {
        pub trait #periph {
            fn poll(&mut self) {}
            fn warm_reset(&mut self) {}
            fn update_reset(&mut self) {}
            #fn_tokens
        }
    });
    Ok(tokens)
}

fn camel_ident(s: &str) -> Ident {
    format_ident!("{}", camel_case(s))
}

fn snake_ident(s: &str) -> Ident {
    format_ident!("{}", snake_case(s))
}

/// Make a peripheral Bus implementation that can be hooked up to a root bus.
fn emu_make_peripheral_bus_impl(block: RegisterBlock) -> Result<TokenStream, DynError> {
    let base = camel_ident(block.name.as_str());
    let periph = format_ident!("{}Peripheral", base);
    let bus = format_ident!("{}Bus", base);
    let mut read_tokens = TokenStream::new();
    let mut write_tokens = TokenStream::new();
    let registers = flatten_registers(0, String::new(), &block);
    registers.iter().for_each(|(offset, base_name, r)| {
        // skip as this register is not defined yet
        if r.name == "MCU_CLK_GATING_EN" {
            return;
        }
        // skip these are they are just for discovery
        if r.name == "TERMINATION_EXTCAP_HEADER" {
            return;
        }
        let base_field = snake_ident(r.name.as_str());
        let base_name = if base_name.is_empty() {
            base_name.clone()
        } else {
            format!("{}_", snake_ident(base_name.as_str()))
        };
        let read_name = format_ident!(
            "{}",
            format!("read_{}{}", base_name, base_field).replace("__", "_")
        );
        let write_name = format_ident!(
            "{}",
            format!("write_{}{}", base_name, base_field).replace("__", "_"),
        );
        let a = hex_literal(offset + r.offset);
        let a1 = hex_literal(offset + r.offset + 1);
        let a3 = hex_literal(offset + r.offset + 3);
        if has_single_32_bit_field(&r.ty) {
            if r.ty.fields[0].ty.can_read() {
                read_tokens.extend(quote! {
                    (size, #a) => Ok(self.periph.#read_name(size)),
                    (_, #a1 ..= #a3) => Err(emulator_bus::BusError::LoadAddrMisaligned),
                });
            }
            if r.ty.fields[0].ty.can_write() {
                write_tokens.extend(quote! {
                    (size, #a) => {
                        self.periph.#write_name(size, val);
                        Ok(())
                    }
                    (_, #a1 ..= #a3) => Err(emulator_bus::BusError::StoreAddrMisaligned),
                });
            }
        } else {
            match r.ty.width {
                RegisterWidth::_8 => {
                    read_tokens.extend(quote! {
                        (emulator_types::RvSize::Byte, #a) => Ok(emulator_types::RvData::from(self.periph.#read_name(emulator_types::RvSize::Byte).reg.get())),
                    });
                    write_tokens.extend(quote! {
                        (emulator_types::RvSize::Byte, #a) => {
                            self.periph.#write_name(emulator_types::RvSize::Byte, emulator_bus::ReadWriteRegister::new(val));
                            Ok(())
                        }
                    });
                }
                RegisterWidth::_16 => {
                    read_tokens.extend(quote! {
                        (emulator_types::RvSize::HalfWord, #a) => Ok(emulator_types::RvData::from(self.periph.#read_name(emulator_types::RvSize::HalfWord).reg.get())),
                        (emulator_types::RvSize::HalfWord, #a1) => Err(emulator_bus::BusError::LoadAddrMisaligned),
                    });
                    write_tokens.extend(quote! {
                        (emulator_types::RvSize::HalfWord, #a) => {
                            self.periph.#write_name(emulator_types::RvSize::HalfWord, emulator_bus::ReadWriteRegister::new(val));
                            Ok(())
                        }
                        (emulator_types::RvSize::HalfWord, #a1) => Err(emulator_bus::BusError::StoreAddrMisaligned),
                    });

                },
                RegisterWidth::_32 => {
                    read_tokens.extend(quote! {
                        (emulator_types::RvSize::Word, #a) => Ok(emulator_types::RvData::from(self.periph.#read_name(emulator_types::RvSize::Word).reg.get())),
                        (emulator_types::RvSize::Word, #a1 ..= #a3) => Err(emulator_bus::BusError::LoadAddrMisaligned),
                    });
                    write_tokens.extend(quote! {
                        (emulator_types::RvSize::Word, #a) => {
                            self.periph.#write_name(emulator_types::RvSize::Word, emulator_bus::ReadWriteRegister::new(val));
                            Ok(())
                        }
                        (emulator_types::RvSize::Word, #a1 ..= #a3) => Err(emulator_bus::BusError::StoreAddrMisaligned),
                    });
                },
                RegisterWidth::_64 => todo!(),
                RegisterWidth::_128 => todo!(),
            }
        }
    });
    let mut tokens = TokenStream::new();
    tokens.extend(quote! {
        pub struct #bus {
            pub periph: Box<dyn #periph>,
        }
        impl emulator_bus::Bus for #bus {
            fn read(&mut self, size: emulator_types::RvSize, addr: emulator_types::RvAddr) -> Result<emulator_types::RvData, emulator_bus::BusError> {
                match (size, addr) {
                    #read_tokens
                    _ => Err(emulator_bus::BusError::LoadAccessFault),
                }
            }
            fn write(&mut self, size: emulator_types::RvSize, addr: emulator_types::RvAddr, val: emulator_types::RvData) -> Result<(), emulator_bus::BusError> {
                match (size, addr) {
                    #write_tokens
                    _ => Err(emulator_bus::BusError::StoreAccessFault),
                }
            }
            fn poll(&mut self) {
                self.periph.poll();
            }
            fn warm_reset(&mut self) {
                self.periph.warm_reset();
            }
            fn update_reset(&mut self) {
                self.periph.update_reset();
            }
        }
    });
    Ok(tokens)
}

/// Calculate the width of a register block.
fn whole_width(block: &RegisterBlock) -> u64 {
    let a = block
        .registers
        .iter()
        .map(|r| r.offset + r.ty.width.in_bytes())
        .sum::<u64>();
    let b = block
        .sub_blocks
        .iter()
        .map(|sb| sb.start_offset() + whole_width(sb.block()))
        .sum::<u64>();
    a.max(b)
}

fn hex_literal(val: u64) -> Literal {
    Literal::from_str(&hex_const(val)).unwrap()
}

// Make the root bus that can be used by the emulator.
fn emu_make_root_bus<'a>(
    blocks: impl Iterator<Item = &'a ValidatedRegisterBlock>,
) -> Result<TokenStream, DynError> {
    let mut read_tokens = TokenStream::new();
    let mut write_tokens = TokenStream::new();
    let mut poll_tokens = TokenStream::new();
    let mut warm_reset_tokens = TokenStream::new();
    let mut update_reset_tokens = TokenStream::new();
    let mut field_tokens = TokenStream::new();
    let mut constructor_tokens = TokenStream::new();
    let mut constructor_params_tokens = TokenStream::new();

    let mut blocks_sorted = blocks.collect::<Vec<_>>();
    blocks_sorted.sort_by_key(|b| b.block().instances[0].address);

    for block in blocks_sorted {
        let rblock = block.block();
        if SKIP_TYPES.contains(rblock.name.as_str()) {
            continue;
        }
        assert_eq!(rblock.instances.len(), 1);
        let snake_base = snake_ident(rblock.name.as_str());
        let periph_field = format_ident!("{}_periph", snake_base);
        let camel_base = camel_ident(rblock.name.as_str());
        let crate_name = format_ident!("{}", rblock.name);
        let periph = format_ident!("{}Peripheral", camel_base);
        let bus = format_ident!("{}Bus", camel_base);
        constructor_params_tokens.extend(quote! {
            #periph_field: Option<Box<dyn crate::#crate_name::#periph>>,
        });
        constructor_tokens.extend(quote! {
            #periph_field: #periph_field.map(|p| crate::#crate_name::#bus { periph: p }),
        });
        field_tokens.extend(quote! {
            pub #periph_field: Option<crate::#crate_name::#bus>,
        });
        let a = hex_literal(rblock.instances[0].address as u64);
        let b = hex_literal(rblock.instances[0].address as u64 + whole_width(rblock));
        read_tokens.extend(quote! {
            #a..=#b => {
                if let Some(periph) = self.#periph_field.as_mut() {
                    periph.read(size, addr - #a)
                } else {
                    Err(emulator_bus::BusError::LoadAccessFault)
                }
            }
        });
        write_tokens.extend(quote! {
            #a..=#b => {
                if let Some(periph) = self.#periph_field.as_mut() {
                    periph.write(size, addr - #a, val)
                } else {
                    Err(emulator_bus::BusError::StoreAccessFault)
                }
            }
        });
        poll_tokens.extend(quote! {
            if let Some(periph) = self.#periph_field.as_mut() {
                periph.poll();
            }
        });
        warm_reset_tokens.extend(quote! {
            if let Some(periph) = self.#periph_field.as_mut() {
                periph.warm_reset();
            }
        });
        update_reset_tokens.extend(quote! {
            if let Some(periph) = self.#periph_field.as_mut() {
                periph.update_reset();
            }
        });
    }
    let mut tokens = TokenStream::new();
    tokens.extend(quote! {
        pub struct AutoRootBus {
            delegate: Option<Box<dyn emulator_bus::Bus>>,
            #field_tokens
        }
        impl AutoRootBus {
            #[allow(clippy::too_many_arguments)]
            pub fn new(
                delegate: Option<Box<dyn emulator_bus::Bus>>,
                #constructor_params_tokens
            ) -> Self {
                Self {
                    delegate,
                    #constructor_tokens
                }
            }
        }
        impl emulator_bus::Bus for AutoRootBus {
            fn read(&mut self, size: emulator_types::RvSize, addr: emulator_types::RvAddr) -> Result<emulator_types::RvData, emulator_bus::BusError> {
                let result = match addr {
                    #read_tokens
                    _ => Err(emulator_bus::BusError::LoadAccessFault),
                };
                if let Some(delegate) = self.delegate.as_mut() {
                    match result {
                        Err(emulator_bus::BusError::LoadAccessFault) => delegate.read(size, addr),
                        _ => result,
                    }
                } else {
                    result
                }
            }
            fn write(&mut self, size: emulator_types::RvSize, addr: emulator_types::RvAddr, val: emulator_types::RvData) -> Result<(), emulator_bus::BusError> {
                let result = match addr {
                    #write_tokens
                    _ => Err(emulator_bus::BusError::StoreAccessFault),
                };
                if let Some(delegate) = self.delegate.as_mut() {
                    match result {
                        Err(emulator_bus::BusError::StoreAccessFault) => delegate.write(size, addr, val),
                        _ => result,
                    }
                } else {
                    result
                }
            }
            fn poll(&mut self) {
                #poll_tokens
                if let Some(delegate) = self.delegate.as_mut() {
                    delegate.poll();
                }
            }
            fn warm_reset(&mut self) {
                #warm_reset_tokens
                if let Some(delegate) = self.delegate.as_mut() {
                    delegate.warm_reset();
                }
            }
            fn update_reset(&mut self) {
                #update_reset_tokens
                if let Some(delegate) = self.delegate.as_mut() {
                    delegate.update_reset();
                }
            }
        }
    });
    Ok(tokens)
}

fn delete_rust_files(dir: &Path) -> Result<(), DynError> {
    for entry in walkdir::WalkDir::new(dir) {
        let entry = entry?;
        if entry.file_type().is_file()
            && entry
                .path()
                .extension()
                .map(|ext| ext == "rs")
                .unwrap_or_default()
        {
            println!("Deleting existing file {}", entry.path().display());
            std::fs::remove_file(entry.path())?;
        }
    }
    Ok(())
}

/// Generate read/write registers used by the firmware.
fn generate_fw_registers(
    check: bool,
    mut root_block: ValidatedRegisterBlock,
    scopes: &[ParentScope],
    header: String,
    dest_dir: &Path,
    register_types_to_crates: &mut HashMap<String, String>,
) -> Result<(), DynError> {
    let file_action = if check {
        file_check_contents
    } else {
        delete_rust_files(dest_dir)?;
        write_file
    };

    let mut blocks = vec![];
    for scope in scopes.iter() {
        blocks.extend(registers_generator::translate_addrmap(*scope)?);
    }
    let mut validated_blocks = vec![];
    for mut block in blocks {
        if block.name.ends_with("_reg") || block.name.ends_with("_csr") {
            block.name = block.name[0..block.name.len() - 4].to_string();
        }
        if block.name == "I3CCSR" {
            block.name = "i3c".to_string();
        }
        if SKIP_TYPES.contains(block.name.as_str()) {
            continue;
        }
        remove_reg_prefixes(
            &mut block.registers,
            &format!("{}_", block.name.to_ascii_lowercase()),
        );
        if block.name == "soc_ifc" {
            block.rename_enum_variants(&[
                ("DEVICE_UNPROVISIONED", "UNPROVISIONED"),
                ("DEVICE_MANUFACTURING", "MANUFACTURING"),
                ("DEVICE_PRODUCTION", "PRODUCTION"),
            ]);
            // Move the TRNG retrieval registers into an independent block;
            // these need to be owned by a separate driver than the rest of
            // soc_ifc.
            let mut trng_block = RegisterBlock {
                name: "soc_ifc_trng".into(),
                instances: vec![RegisterBlockInstance {
                    name: "soc_ifc_trng_reg".into(),
                    address: block.instances[0].address,
                }],
                ..Default::default()
            };
            block.registers.retain(|field| {
                if matches!(field.name.as_str(), "CPTRA_TRNG_DATA" | "CPTRA_TRNG_STATUS") {
                    trng_block.registers.push(field.clone());
                    false // remove field from soc_ifc
                } else {
                    true // keep field
                }
            });
            let trng_block = trng_block.validate_and_dedup()?;
            validated_blocks.push(trng_block);
        }

        let block = block.validate_and_dedup()?;
        validated_blocks.push(block);
    }
    let mut root_submod_tokens = String::new();

    let mut all_blocks: Vec<_> = std::iter::once(&mut root_block)
        .chain(validated_blocks.iter_mut())
        .collect();
    registers_generator::filter_unused_types(&mut all_blocks);

    for block in validated_blocks {
        let module_ident = block.block().name.clone();
        let dest_file = dest_dir.join(format!("{}.rs", block.block().name));
        let tokens = registers_generator::generate_code(
            &format!("crate::{}::", block.block().name),
            &block,
            false,
            register_types_to_crates,
        );
        root_submod_tokens += &format!("pub mod {module_ident};\n");
        file_action(
            &dest_file,
            &rustfmt(&(header.clone() + &tokens.to_string()))?,
        )?;
    }
    let root_type_tokens =
        registers_generator::generate_code("crate::", &root_block, true, register_types_to_crates);
    let recursion = "#![recursion_limit = \"256\"]\n";
    let root_tokens = root_type_tokens;
    file_action(
        &dest_dir.join("lib.rs"),
        &rustfmt(&(header.clone() + recursion + &root_tokens.to_string() + &root_submod_tokens))?,
    )?;
    Ok(())
}

/// Run a command and return its stdout as a string.
fn run_cmd_stdout(cmd: &mut Command, input: Option<&[u8]>) -> Result<String, DynError> {
    cmd.stdin(Stdio::piped());
    cmd.stdout(Stdio::piped());

    let mut child = cmd.spawn()?;
    if let (Some(mut stdin), Some(input)) = (child.stdin.take(), input) {
        std::io::Write::write_all(&mut stdin, input)?;
    }
    let out = child.wait_with_output()?;
    if out.status.success() {
        Ok(String::from_utf8_lossy(&out.stdout).into())
    } else {
        Err(format!(
            "Process {:?} {:?} exited with status code {:?} stderr {}",
            cmd.get_program(),
            cmd.get_args(),
            out.status.code(),
            String::from_utf8_lossy(&out.stderr)
        )
        .into())
    }
}

/// Remove the given prefix from the register names, if present.
fn remove_reg_prefixes(registers: &mut [Rc<Register>], prefix: &str) {
    for reg in registers.iter_mut() {
        if reg.name.to_ascii_lowercase().starts_with(prefix) {
            let reg = Rc::make_mut(reg);
            reg.name = reg.name[prefix.len()..].to_string();
        }
    }
}

/// Format the given Rust code using rustfmt.
fn rustfmt(code: &str) -> Result<String, DynError> {
    run_cmd_stdout(
        Command::new("rustfmt")
            .arg("--emit=stdout")
            .arg("--config=normalize_comments=true,normalize_doc_attributes=true"),
        Some(code.as_bytes()),
    )
}

fn write_file(dest_file: &Path, contents: &str) -> Result<(), DynError> {
    println!("Writing to {dest_file:?}");
    std::fs::write(PROJECT_ROOT.join(dest_file), contents)?;
    Ok(())
}

fn file_check_contents(dest_file: &Path, expected_contents: &str) -> Result<(), DynError> {
    println!("Checking file {dest_file:?}");
    let actual_contents = std::fs::read(dest_file)?;
    if actual_contents != expected_contents.as_bytes() {
        return Err(format!(
            "{dest_file:?} does not match the generator output. If this is \
            unexpected, ensure that the caliptra-rtl, caliptra-ss, and i3c-core \
            submodules are pointing to the correct commits and/or run
            \"git submodule update\". Otherwise, run \
            \"cargo xtask registers-autogen\" to update this file."
        )
        .into());
    }
    Ok(())
}
