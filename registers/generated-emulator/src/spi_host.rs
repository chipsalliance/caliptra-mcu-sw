// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-rtl repo at 0e43b8e7011c1c8761e114bc949fcad6cf30538e
// , caliptra-ss repo at 9911c2b0e4bac9e4b48f6c2155c86cb116159734
// , and i3c-core repo at d5c715103f529ade0e5d375a53c5692daaa9c54b
//
#[derive(Clone, Copy, Default)]
pub struct InterruptStateReadVal(u32);
impl InterruptStateReadVal {
    /// Error-related interrupts, see !!ERROR_ENABLE register for more
    /// information.
    #[inline(always)]
    pub fn error(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Event-related interrupts, see !!EVENT_ENABLE register for more
    /// information.
    #[inline(always)]
    pub fn spi_event(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptStateWriteVal {
        InterruptStateWriteVal(self.0)
    }
}
impl From<u32> for InterruptStateReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStateReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStateReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptStateWriteVal(u32);
impl InterruptStateWriteVal {
    /// Error-related interrupts, see !!ERROR_ENABLE register for more
    /// information.
    #[inline(always)]
    pub fn error(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Event-related interrupts, see !!EVENT_ENABLE register for more
    /// information.
    #[inline(always)]
    pub fn spi_event(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for InterruptStateWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStateWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStateWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableReadVal(u32);
impl InterruptEnableReadVal {
    /// Enable interrupt when error is set.
    #[inline(always)]
    pub fn error(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Enable interrupt when spi_event is set.
    #[inline(always)]
    pub fn spi_event(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptEnableWriteVal {
        InterruptEnableWriteVal(self.0)
    }
}
impl From<u32> for InterruptEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableWriteVal(u32);
impl InterruptEnableWriteVal {
    /// Enable interrupt when error is set.
    #[inline(always)]
    pub fn error(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Enable interrupt when spi_event is set.
    #[inline(always)]
    pub fn spi_event(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for InterruptEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptTestReadVal(u32);
impl InterruptTestReadVal {
    /// Write 1 to force error to 1.
    #[inline(always)]
    pub fn error(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Write 1 to force spi_event to 1.
    #[inline(always)]
    pub fn spi_event(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptTestWriteVal {
        InterruptTestWriteVal(self.0)
    }
}
impl From<u32> for InterruptTestReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptTestReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptTestReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptTestWriteVal(u32);
impl InterruptTestWriteVal {
    /// Write 1 to force error to 1.
    #[inline(always)]
    pub fn error(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Write 1 to force spi_event to 1.
    #[inline(always)]
    pub fn spi_event(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for InterruptTestWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptTestWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptTestWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct AlertTestReadVal(u32);
impl AlertTestReadVal {
    /// Write 1 to trigger one alert event of this kind.
    #[inline(always)]
    pub fn fatal_fault(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> AlertTestWriteVal {
        AlertTestWriteVal(self.0)
    }
}
impl From<u32> for AlertTestReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<AlertTestReadVal> for u32 {
    #[inline(always)]
    fn from(val: AlertTestReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct AlertTestWriteVal(u32);
impl AlertTestWriteVal {
    /// Write 1 to trigger one alert event of this kind.
    #[inline(always)]
    pub fn fatal_fault(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for AlertTestWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<AlertTestWriteVal> for u32 {
    #[inline(always)]
    fn from(val: AlertTestWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControlReadVal(u32);
impl ControlReadVal {
    /// If !!EVENT_ENABLE.RXWM is set, the IP will send
    /// an interrupt when the depth of the RX FIFO reaches
    /// RX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn rx_watermark(&self) -> u32 {
        self.0 & 0xff
    }
    /// If !!EVENT_ENABLE.TXWM is set, the IP will send
    /// an interrupt when the depth of the TX FIFO drops below
    /// TX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn tx_watermark(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Enable the SPI host output buffers for the sck, csb, and sd lines.  This allows
    /// the SPI_HOST IP to connect to the same bus as other SPI controllers without
    /// interference.
    #[inline(always)]
    pub fn output_en(&self) -> bool {
        ((self.0 >> 29) & 1) != 0
    }
    /// Clears the entire IP to the reset state when set to 1, including
    /// the FIFOs, the CDC's, the core state machine and the shift register.
    /// In the current implementation, the CDC FIFOs are drained not reset.
    /// Therefore software must confirm that both FIFO's empty before releasing
    /// the IP from reset.
    #[inline(always)]
    pub fn sw_rst(&self) -> bool {
        ((self.0 >> 30) & 1) != 0
    }
    /// Enables the SPI host.  On reset, this field is 0, meaning
    /// that no transactions can proceed.
    #[inline(always)]
    pub fn spien(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ControlWriteVal {
        ControlWriteVal(self.0)
    }
}
impl From<u32> for ControlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControlReadVal> for u32 {
    #[inline(always)]
    fn from(val: ControlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControlWriteVal(u32);
impl ControlWriteVal {
    /// If !!EVENT_ENABLE.RXWM is set, the IP will send
    /// an interrupt when the depth of the RX FIFO reaches
    /// RX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn rx_watermark(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
    /// If !!EVENT_ENABLE.TXWM is set, the IP will send
    /// an interrupt when the depth of the TX FIFO drops below
    /// TX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn tx_watermark(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// Enable the SPI host output buffers for the sck, csb, and sd lines.  This allows
    /// the SPI_HOST IP to connect to the same bus as other SPI controllers without
    /// interference.
    #[inline(always)]
    pub fn output_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
    }
    /// Clears the entire IP to the reset state when set to 1, including
    /// the FIFOs, the CDC's, the core state machine and the shift register.
    /// In the current implementation, the CDC FIFOs are drained not reset.
    /// Therefore software must confirm that both FIFO's empty before releasing
    /// the IP from reset.
    #[inline(always)]
    pub fn sw_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
    }
    /// Enables the SPI host.  On reset, this field is 0, meaning
    /// that no transactions can proceed.
    #[inline(always)]
    pub fn spien(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
}
impl From<u32> for ControlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ControlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StatusReadVal(u32);
impl StatusReadVal {
    /// Transmit queue depth. Indicates how many unsent 32-bit words
    /// are currently in the TX FIFO.  When active, this result may
    /// be an overestimate due to synchronization delays,
    #[inline(always)]
    pub fn txqd(&self) -> u32 {
        self.0 & 0xff
    }
    /// Receive queue depth. Indicates how many unread 32-bit words are
    /// currently in the RX FIFO.  When active, this result may an
    /// underestimate due to synchronization delays.
    #[inline(always)]
    pub fn rxqd(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Command queue depth. Indicates how many unread 32-bit words are
    /// currently in the command segment queue.
    #[inline(always)]
    pub fn cmdqd(&self) -> u32 {
        (self.0 >> 16) & 0xf
    }
    /// If high, the number of 32-bits in the RX FIFO now exceeds the
    /// !!CONTROL.RX_WATERMARK entries (32b each).
    #[inline(always)]
    pub fn rxwm(&self) -> bool {
        ((self.0 >> 20) & 1) != 0
    }
    /// The value of the ByteOrder parameter, provided so that firmware
    /// can confirm proper IP configuration.
    #[inline(always)]
    pub fn byteorder(&self) -> bool {
        ((self.0 >> 22) & 1) != 0
    }
    /// If high, signifies that an ongoing transaction has stalled
    /// due to lack of available space in the RX FIFO
    #[inline(always)]
    pub fn rxstall(&self) -> bool {
        ((self.0 >> 23) & 1) != 0
    }
    /// When high, indicates that the receive fifo is empty.
    /// Any reads from RX FIFO will cause an error interrupt.
    #[inline(always)]
    pub fn rxempty(&self) -> bool {
        ((self.0 >> 24) & 1) != 0
    }
    /// When high, indicates that the receive fifo is full.  Any
    /// ongoing transactions will stall until firmware reads some
    /// data from !!RXDATA.
    #[inline(always)]
    pub fn rxfull(&self) -> bool {
        ((self.0 >> 25) & 1) != 0
    }
    /// If high, the amount of data in the TX FIFO has fallen below the
    /// level of !!CONTROL.TX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn txwm(&self) -> bool {
        ((self.0 >> 26) & 1) != 0
    }
    /// If high, signifies that an ongoing transaction has stalled
    /// due to lack of data in the TX FIFO
    #[inline(always)]
    pub fn txstall(&self) -> bool {
        ((self.0 >> 27) & 1) != 0
    }
    /// When high, indicates that the transmit data fifo is empty.
    #[inline(always)]
    pub fn txempty(&self) -> bool {
        ((self.0 >> 28) & 1) != 0
    }
    /// When high, indicates that the transmit data fifo is full.
    /// Any further writes to !!RXDATA will create an error interrupt.
    #[inline(always)]
    pub fn txfull(&self) -> bool {
        ((self.0 >> 29) & 1) != 0
    }
    /// When high, indicates the SPI host is processing a previously
    /// issued command.
    #[inline(always)]
    pub fn active(&self) -> bool {
        ((self.0 >> 30) & 1) != 0
    }
    /// When high, indicates the SPI host is ready to receive
    /// commands. Writing to COMMAND when READY is low is
    /// an error, and will trigger an interrupt.
    #[inline(always)]
    pub fn ready(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StatusWriteVal {
        StatusWriteVal(self.0)
    }
}
impl From<u32> for StatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: StatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StatusWriteVal(u32);
impl StatusWriteVal {
    /// Transmit queue depth. Indicates how many unsent 32-bit words
    /// are currently in the TX FIFO.  When active, this result may
    /// be an overestimate due to synchronization delays,
    #[inline(always)]
    pub fn txqd(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
    /// Receive queue depth. Indicates how many unread 32-bit words are
    /// currently in the RX FIFO.  When active, this result may an
    /// underestimate due to synchronization delays.
    #[inline(always)]
    pub fn rxqd(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// Command queue depth. Indicates how many unread 32-bit words are
    /// currently in the command segment queue.
    #[inline(always)]
    pub fn cmdqd(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 16)) | ((val & 0xf) << 16))
    }
    /// If high, the number of 32-bits in the RX FIFO now exceeds the
    /// !!CONTROL.RX_WATERMARK entries (32b each).
    #[inline(always)]
    pub fn rxwm(self, val: bool) -> Self {
        Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
    }
    /// The value of the ByteOrder parameter, provided so that firmware
    /// can confirm proper IP configuration.
    #[inline(always)]
    pub fn byteorder(self, val: bool) -> Self {
        Self((self.0 & !(1 << 22)) | (u32::from(val) << 22))
    }
    /// If high, signifies that an ongoing transaction has stalled
    /// due to lack of available space in the RX FIFO
    #[inline(always)]
    pub fn rxstall(self, val: bool) -> Self {
        Self((self.0 & !(1 << 23)) | (u32::from(val) << 23))
    }
    /// When high, indicates that the receive fifo is empty.
    /// Any reads from RX FIFO will cause an error interrupt.
    #[inline(always)]
    pub fn rxempty(self, val: bool) -> Self {
        Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
    }
    /// When high, indicates that the receive fifo is full.  Any
    /// ongoing transactions will stall until firmware reads some
    /// data from !!RXDATA.
    #[inline(always)]
    pub fn rxfull(self, val: bool) -> Self {
        Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
    }
    /// If high, the amount of data in the TX FIFO has fallen below the
    /// level of !!CONTROL.TX_WATERMARK words (32b each).
    #[inline(always)]
    pub fn txwm(self, val: bool) -> Self {
        Self((self.0 & !(1 << 26)) | (u32::from(val) << 26))
    }
    /// If high, signifies that an ongoing transaction has stalled
    /// due to lack of data in the TX FIFO
    #[inline(always)]
    pub fn txstall(self, val: bool) -> Self {
        Self((self.0 & !(1 << 27)) | (u32::from(val) << 27))
    }
    /// When high, indicates that the transmit data fifo is empty.
    #[inline(always)]
    pub fn txempty(self, val: bool) -> Self {
        Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
    }
    /// When high, indicates that the transmit data fifo is full.
    /// Any further writes to !!RXDATA will create an error interrupt.
    #[inline(always)]
    pub fn txfull(self, val: bool) -> Self {
        Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
    }
    /// When high, indicates the SPI host is processing a previously
    /// issued command.
    #[inline(always)]
    pub fn active(self, val: bool) -> Self {
        Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
    }
    /// When high, indicates the SPI host is ready to receive
    /// commands. Writing to COMMAND when READY is low is
    /// an error, and will trigger an interrupt.
    #[inline(always)]
    pub fn ready(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
}
impl From<u32> for StatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ConfigoptsReadVal(u32);
impl ConfigoptsReadVal {
    /// Core clock divider.  Slows down subsequent SPI transactions by a
    /// factor of (CLKDIV+1) relative to the core clock frequency.  The
    /// period of sck, T(sck) then becomes `2*(CLK_DIV+1)*T(core)`
    #[inline(always)]
    pub fn clkdiv(&self) -> u32 {
        self.0 & 0xffff
    }
    /// Minimum idle time between commands. Indicates the minimum
    /// number of sck half-cycles to hold cs_n high between commands.
    /// Setting this register to zero creates a minimally-wide CS_N-high
    /// pulse of one-half sck cycle.
    #[inline(always)]
    pub fn csnidle(&self) -> u32 {
        (self.0 >> 16) & 0xf
    }
    /// CS_N Trailing Time.  Indicates the number of half sck cycles,
    /// CSNTRAIL+1, to leave between last edge of sck and the rising
    /// edge of cs_n. Setting this register to zero corresponds
    /// to the minimum delay of one-half sck cycle.
    #[inline(always)]
    pub fn csntrail(&self) -> u32 {
        (self.0 >> 20) & 0xf
    }
    /// CS_N Leading Time.  Indicates the number of half sck cycles,
    /// CSNLEAD+1, to leave between the falling edge of cs_n and
    /// the first edge of sck.  Setting this register to zero
    /// corresponds to the minimum delay of one-half sck cycle
    #[inline(always)]
    pub fn csnlead(&self) -> u32 {
        (self.0 >> 24) & 0xf
    }
    /// Full cycle.  Modifies the CPHA sampling behaviour to allow
    /// for longer device logic setup times.  Rather than sampling the SD
    /// bus a half cycle after shifting out data, the data is sampled
    /// a full cycle after shifting data out.  This means that if
    /// CPHA = 0, data is shifted out on the trailing edge, and
    /// sampled a full cycle later.  If CPHA = 1, data is shifted and
    /// sampled with the trailing edge, also separated by a
    /// full cycle.
    #[inline(always)]
    pub fn fullcyc(&self) -> bool {
        ((self.0 >> 29) & 1) != 0
    }
    /// The phase of the sck clock signal relative to the data. When
    /// CPHA = 0, the data changes on the trailing edge of sck
    /// and is typically sampled on the leading edge.  Conversely
    /// if CPHA = 1 high, data lines change on the leading edge of
    /// sck and are typically sampled on the trailing edge.
    /// CPHA should be chosen to match the phase of the selected
    /// device.  The sampling behavior is modified by the
    /// !!CONFIGOPTS.FULLCYC bit.
    #[inline(always)]
    pub fn cpha(&self) -> bool {
        ((self.0 >> 30) & 1) != 0
    }
    /// The polarity of the sck clock signal.  When CPOL is 0,
    /// sck is low when idle, and emits high pulses.   When CPOL
    /// is low, sck is high when idle, and emits a series of low
    /// pulses.
    #[inline(always)]
    pub fn cpol(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ConfigoptsWriteVal {
        ConfigoptsWriteVal(self.0)
    }
}
impl From<u32> for ConfigoptsReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ConfigoptsReadVal> for u32 {
    #[inline(always)]
    fn from(val: ConfigoptsReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ConfigoptsWriteVal(u32);
impl ConfigoptsWriteVal {
    /// Core clock divider.  Slows down subsequent SPI transactions by a
    /// factor of (CLKDIV+1) relative to the core clock frequency.  The
    /// period of sck, T(sck) then becomes `2*(CLK_DIV+1)*T(core)`
    #[inline(always)]
    pub fn clkdiv(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
    /// Minimum idle time between commands. Indicates the minimum
    /// number of sck half-cycles to hold cs_n high between commands.
    /// Setting this register to zero creates a minimally-wide CS_N-high
    /// pulse of one-half sck cycle.
    #[inline(always)]
    pub fn csnidle(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 16)) | ((val & 0xf) << 16))
    }
    /// CS_N Trailing Time.  Indicates the number of half sck cycles,
    /// CSNTRAIL+1, to leave between last edge of sck and the rising
    /// edge of cs_n. Setting this register to zero corresponds
    /// to the minimum delay of one-half sck cycle.
    #[inline(always)]
    pub fn csntrail(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 20)) | ((val & 0xf) << 20))
    }
    /// CS_N Leading Time.  Indicates the number of half sck cycles,
    /// CSNLEAD+1, to leave between the falling edge of cs_n and
    /// the first edge of sck.  Setting this register to zero
    /// corresponds to the minimum delay of one-half sck cycle
    #[inline(always)]
    pub fn csnlead(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 24)) | ((val & 0xf) << 24))
    }
    /// Full cycle.  Modifies the CPHA sampling behaviour to allow
    /// for longer device logic setup times.  Rather than sampling the SD
    /// bus a half cycle after shifting out data, the data is sampled
    /// a full cycle after shifting data out.  This means that if
    /// CPHA = 0, data is shifted out on the trailing edge, and
    /// sampled a full cycle later.  If CPHA = 1, data is shifted and
    /// sampled with the trailing edge, also separated by a
    /// full cycle.
    #[inline(always)]
    pub fn fullcyc(self, val: bool) -> Self {
        Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
    }
    /// The phase of the sck clock signal relative to the data. When
    /// CPHA = 0, the data changes on the trailing edge of sck
    /// and is typically sampled on the leading edge.  Conversely
    /// if CPHA = 1 high, data lines change on the leading edge of
    /// sck and are typically sampled on the trailing edge.
    /// CPHA should be chosen to match the phase of the selected
    /// device.  The sampling behavior is modified by the
    /// !!CONFIGOPTS.FULLCYC bit.
    #[inline(always)]
    pub fn cpha(self, val: bool) -> Self {
        Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
    }
    /// The polarity of the sck clock signal.  When CPOL is 0,
    /// sck is low when idle, and emits high pulses.   When CPOL
    /// is low, sck is high when idle, and emits a series of low
    /// pulses.
    #[inline(always)]
    pub fn cpol(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
}
impl From<u32> for ConfigoptsWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ConfigoptsWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ConfigoptsWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CommandReadVal(u32);
impl CommandReadVal {
    /// Segment Length.
    ///
    /// For read or write segments, this field controls the
    /// number of 1-byte bursts to transmit and or receive in
    /// this command segment.  The number of cyles required
    /// to send or received a byte will depend on !!COMMAND.SPEED.
    /// For dummy segments, (!!COMMAND.DIRECTION == 0), this register
    /// controls the number of dummy cycles to issue.
    /// The number of bytes (or dummy cycles) in the segment will be
    /// equal to !!COMMAND.LEN + 1.
    #[inline(always)]
    #[allow(clippy::len_without_is_empty)]
    pub fn len(&self) -> u32 {
        self.0 & 0x1ff
    }
    /// Chip select active after transaction.  If CSAAT = 0, the
    /// chip select line is raised immediately at the end of the
    /// command segment.   If !!COMMAND.CSAAT = 1, the chip select
    /// line is left low at the end of the current transaction
    /// segment.  This allows the creation longer, more
    /// complete SPI transactions, consisting of several separate
    /// segments for issuing instructions, pausing for dummy cycles,
    /// and transmitting or receiving data from the device.
    #[inline(always)]
    pub fn csaat(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// The speed for this command segment: "0" = Standard SPI. "1" = Dual SPI.
    /// "2"=Quad SPI,  "3": RESERVED.
    #[inline(always)]
    pub fn speed(&self) -> u32 {
        (self.0 >> 10) & 3
    }
    /// The direction for the following command: "0" = Dummy cycles
    /// (no TX/RX). "1" = Rx only, "2" = Tx only, "3" = Bidirectional
    /// Tx/Rx (Standard SPI mode only).
    #[inline(always)]
    pub fn direction(&self) -> u32 {
        (self.0 >> 12) & 3
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> CommandWriteVal {
        CommandWriteVal(self.0)
    }
}
impl From<u32> for CommandReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CommandReadVal> for u32 {
    #[inline(always)]
    fn from(val: CommandReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CommandWriteVal(u32);
impl CommandWriteVal {
    /// Segment Length.
    ///
    /// For read or write segments, this field controls the
    /// number of 1-byte bursts to transmit and or receive in
    /// this command segment.  The number of cyles required
    /// to send or received a byte will depend on !!COMMAND.SPEED.
    /// For dummy segments, (!!COMMAND.DIRECTION == 0), this register
    /// controls the number of dummy cycles to issue.
    /// The number of bytes (or dummy cycles) in the segment will be
    /// equal to !!COMMAND.LEN + 1.
    #[inline(always)]
    pub fn len(self, val: u32) -> Self {
        Self((self.0 & !(0x1ff)) | (val & 0x1ff))
    }
    /// Chip select active after transaction.  If CSAAT = 0, the
    /// chip select line is raised immediately at the end of the
    /// command segment.   If !!COMMAND.CSAAT = 1, the chip select
    /// line is left low at the end of the current transaction
    /// segment.  This allows the creation longer, more
    /// complete SPI transactions, consisting of several separate
    /// segments for issuing instructions, pausing for dummy cycles,
    /// and transmitting or receiving data from the device.
    #[inline(always)]
    pub fn csaat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// The speed for this command segment: "0" = Standard SPI. "1" = Dual SPI.
    /// "2"=Quad SPI,  "3": RESERVED.
    #[inline(always)]
    pub fn speed(self, val: u32) -> Self {
        Self((self.0 & !(3 << 10)) | ((val & 3) << 10))
    }
    /// The direction for the following command: "0" = Dummy cycles
    /// (no TX/RX). "1" = Rx only, "2" = Tx only, "3" = Bidirectional
    /// Tx/Rx (Standard SPI mode only).
    #[inline(always)]
    pub fn direction(self, val: u32) -> Self {
        Self((self.0 & !(3 << 12)) | ((val & 3) << 12))
    }
}
impl From<u32> for CommandWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CommandWriteVal> for u32 {
    #[inline(always)]
    fn from(val: CommandWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ErrorEnableReadVal(u32);
impl ErrorEnableReadVal {
    /// Command Error: If this bit is set, the block sends an error
    /// interrupt whenever a command is issued while busy (i.e. a 1 is
    /// when !!STATUS.READY is not asserted.)
    #[inline(always)]
    pub fn cmdbusy(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Overflow Errors: If this bit is set, the block sends an
    /// error interrupt whenever the TX FIFO overflows.
    #[inline(always)]
    pub fn overflow(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Underflow Errors: If this bit is set, the block sends an
    /// error interrupt whenever there is a read from !!RXDATA
    /// but the RX FIFO is empty.
    #[inline(always)]
    pub fn underflow(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Invalid Command Errors: If this bit is set, the block sends an
    /// error interrupt whenever a command is sent with invalid values for
    /// !!COMMAND.SPEED or !!COMMAND.DIRECTION.
    #[inline(always)]
    pub fn cmdinval(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Invalid CSID: If this bit is set, the block sends an error interrupt whenever
    /// a command is submitted, but CSID exceeds NumCS.
    #[inline(always)]
    pub fn csidinval(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ErrorEnableWriteVal {
        ErrorEnableWriteVal(self.0)
    }
}
impl From<u32> for ErrorEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ErrorEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: ErrorEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ErrorEnableWriteVal(u32);
impl ErrorEnableWriteVal {
    /// Command Error: If this bit is set, the block sends an error
    /// interrupt whenever a command is issued while busy (i.e. a 1 is
    /// when !!STATUS.READY is not asserted.)
    #[inline(always)]
    pub fn cmdbusy(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Overflow Errors: If this bit is set, the block sends an
    /// error interrupt whenever the TX FIFO overflows.
    #[inline(always)]
    pub fn overflow(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Underflow Errors: If this bit is set, the block sends an
    /// error interrupt whenever there is a read from !!RXDATA
    /// but the RX FIFO is empty.
    #[inline(always)]
    pub fn underflow(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Invalid Command Errors: If this bit is set, the block sends an
    /// error interrupt whenever a command is sent with invalid values for
    /// !!COMMAND.SPEED or !!COMMAND.DIRECTION.
    #[inline(always)]
    pub fn cmdinval(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Invalid CSID: If this bit is set, the block sends an error interrupt whenever
    /// a command is submitted, but CSID exceeds NumCS.
    #[inline(always)]
    pub fn csidinval(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
}
impl From<u32> for ErrorEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ErrorEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ErrorEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ErrorStatusReadVal(u32);
impl ErrorStatusReadVal {
    /// Indicates a write to !!COMMAND when !!STATUS.READY = 0.
    #[inline(always)]
    pub fn cmdbusy(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Indicates that firmware has overflowed the TX FIFO
    #[inline(always)]
    pub fn overflow(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Indicates that firmware has attempted to read from
    /// !!RXDATA when the RX FIFO is empty.
    #[inline(always)]
    pub fn underflow(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Indicates an invalid command segment, meaning either an invalid value of
    /// !!COMMAND.SPEED or a request for bidirectional data transfer at dual or quad
    /// speed
    #[inline(always)]
    pub fn cmdinval(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Indicates a command was attempted with an invalid value for !!CSID.
    #[inline(always)]
    pub fn csidinval(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Indicates that TLUL attempted to write to TXDATA with no bytes enabled. Such
    /// 'zero byte' writes are not supported.
    #[inline(always)]
    pub fn accessinval(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ErrorStatusWriteVal {
        ErrorStatusWriteVal(self.0)
    }
}
impl From<u32> for ErrorStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ErrorStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: ErrorStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ErrorStatusWriteVal(u32);
impl ErrorStatusWriteVal {
    /// Indicates a write to !!COMMAND when !!STATUS.READY = 0.
    #[inline(always)]
    pub fn cmdbusy(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Indicates that firmware has overflowed the TX FIFO
    #[inline(always)]
    pub fn overflow(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Indicates that firmware has attempted to read from
    /// !!RXDATA when the RX FIFO is empty.
    #[inline(always)]
    pub fn underflow(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Indicates an invalid command segment, meaning either an invalid value of
    /// !!COMMAND.SPEED or a request for bidirectional data transfer at dual or quad
    /// speed
    #[inline(always)]
    pub fn cmdinval(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Indicates a command was attempted with an invalid value for !!CSID.
    #[inline(always)]
    pub fn csidinval(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Indicates that TLUL attempted to write to TXDATA with no bytes enabled. Such
    /// 'zero byte' writes are not supported.
    #[inline(always)]
    pub fn accessinval(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
}
impl From<u32> for ErrorStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ErrorStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ErrorStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct EventEnableReadVal(u32);
impl EventEnableReadVal {
    /// Assert to send a spi_event interrupt whenever !!STATUS.RXFULL
    /// goes high
    #[inline(always)]
    pub fn rxfull(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.TXEMPTY
    /// goes high
    #[inline(always)]
    pub fn txempty(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
    /// the RX FIFO is greater than !!CONTROL.RX_WATERMARK. To prevent the
    /// reassertion of this interrupt, read more data from the RX FIFO, or
    /// increase !!CONTROL.RX_WATERMARK.
    #[inline(always)]
    pub fn rxwm(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
    /// the TX FIFO is less than !!CONTROL.TX_WATERMARK.  To prevent the
    /// reassertion of this interrupt add more data to the TX FIFO, or
    /// reduce !!CONTROL.TX_WATERMARK.
    #[inline(always)]
    pub fn txwm(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.READY
    /// goes high
    #[inline(always)]
    pub fn ready(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.ACTIVE
    /// goes low
    #[inline(always)]
    pub fn idle(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> EventEnableWriteVal {
        EventEnableWriteVal(self.0)
    }
}
impl From<u32> for EventEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<EventEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: EventEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct EventEnableWriteVal(u32);
impl EventEnableWriteVal {
    /// Assert to send a spi_event interrupt whenever !!STATUS.RXFULL
    /// goes high
    #[inline(always)]
    pub fn rxfull(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.TXEMPTY
    /// goes high
    #[inline(always)]
    pub fn txempty(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
    /// the RX FIFO is greater than !!CONTROL.RX_WATERMARK. To prevent the
    /// reassertion of this interrupt, read more data from the RX FIFO, or
    /// increase !!CONTROL.RX_WATERMARK.
    #[inline(always)]
    pub fn rxwm(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Assert to send a spi_event interrupt whenever the number of 32-bit words in
    /// the TX FIFO is less than !!CONTROL.TX_WATERMARK.  To prevent the
    /// reassertion of this interrupt add more data to the TX FIFO, or
    /// reduce !!CONTROL.TX_WATERMARK.
    #[inline(always)]
    pub fn txwm(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.READY
    /// goes high
    #[inline(always)]
    pub fn ready(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Assert to send a spi_event interrupt whenever !!STATUS.ACTIVE
    /// goes low
    #[inline(always)]
    pub fn idle(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
}
impl From<u32> for EventEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<EventEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: EventEnableWriteVal) -> u32 {
        val.0
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub trait SpiHostPeripheral {
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_interrupt_state(&mut self) -> InterruptStateWriteVal {
        InterruptStateWriteVal::default()
    }
    fn write_interrupt_state(&mut self, _val: InterruptStateReadVal) {}
    fn read_interrupt_enable(&mut self) -> InterruptEnableWriteVal {
        InterruptEnableWriteVal::default()
    }
    fn write_interrupt_enable(&mut self, _val: InterruptEnableReadVal) {}
    fn read_interrupt_test(&mut self) -> InterruptTestWriteVal {
        InterruptTestWriteVal::default()
    }
    fn write_interrupt_test(&mut self, _val: InterruptTestReadVal) {}
    fn read_alert_test(&mut self) -> AlertTestWriteVal {
        AlertTestWriteVal::default()
    }
    fn write_alert_test(&mut self, _val: AlertTestReadVal) {}
    fn read_control(&mut self) -> ControlWriteVal {
        ControlWriteVal::default()
    }
    fn write_control(&mut self, _val: ControlReadVal) {}
    fn read_status(&mut self) -> StatusWriteVal {
        StatusWriteVal::default()
    }
    fn write_status(&mut self, _val: StatusReadVal) {}
    fn read_configopts(&mut self) -> ConfigoptsWriteVal {
        ConfigoptsWriteVal::default()
    }
    fn write_configopts(&mut self, _val: ConfigoptsReadVal) {}
    fn read_csid(&mut self) -> u32 {
        0
    }
    fn write_csid(&mut self, _val: u32) {}
    fn read_command(&mut self) -> CommandWriteVal {
        CommandWriteVal::default()
    }
    fn write_command(&mut self, _val: CommandReadVal) {}
    fn read_rxdata(&mut self) -> u32 {
        0
    }
    fn write_rxdata(&mut self, _val: u32) {}
    fn read_txdata(&mut self) -> u32 {
        0
    }
    fn write_txdata(&mut self, _val: u32) {}
    fn read_error_enable(&mut self) -> ErrorEnableWriteVal {
        ErrorEnableWriteVal::default()
    }
    fn write_error_enable(&mut self, _val: ErrorEnableReadVal) {}
    fn read_error_status(&mut self) -> ErrorStatusWriteVal {
        ErrorStatusWriteVal::default()
    }
    fn write_error_status(&mut self, _val: ErrorStatusReadVal) {}
    fn read_event_enable(&mut self) -> EventEnableWriteVal {
        EventEnableWriteVal::default()
    }
    fn write_event_enable(&mut self, _val: EventEnableReadVal) {}
}
pub struct SpiHostBus {
    pub periph: Box<dyn SpiHostPeripheral>,
}
impl emulator_bus::Bus for SpiHostBus {
    fn read(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
    ) -> Result<emulator_types::RvData, emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => Ok(emulator_types::RvData::from(
                self.periph.read_interrupt_state(),
            )),
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 4) => Ok(emulator_types::RvData::from(
                self.periph.read_interrupt_enable(),
            )),
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => Ok(emulator_types::RvData::from(
                self.periph.read_interrupt_test(),
            )),
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => {
                Ok(emulator_types::RvData::from(self.periph.read_alert_test()))
            }
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10) => {
                Ok(emulator_types::RvData::from(self.periph.read_control()))
            }
            (emulator_types::RvSize::Word, 0x11..=0x13) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14) => {
                Ok(emulator_types::RvData::from(self.periph.read_status()))
            }
            (emulator_types::RvSize::Word, 0x15..=0x17) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x18) => {
                Ok(emulator_types::RvData::from(self.periph.read_configopts()))
            }
            (emulator_types::RvSize::Word, 0x19..=0x1b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                Ok(emulator_types::RvData::from(self.periph.read_csid()))
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                Ok(emulator_types::RvData::from(self.periph.read_command()))
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x2c) => {
                Ok(emulator_types::RvData::from(self.periph.read_txdata()))
            }
            (emulator_types::RvSize::Word, 0x2d..=0x2f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x30) => Ok(emulator_types::RvData::from(
                self.periph.read_error_enable(),
            )),
            (emulator_types::RvSize::Word, 0x31..=0x33) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x34) => Ok(emulator_types::RvData::from(
                self.periph.read_error_status(),
            )),
            (emulator_types::RvSize::Word, 0x35..=0x37) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x38) => Ok(emulator_types::RvData::from(
                self.periph.read_event_enable(),
            )),
            (emulator_types::RvSize::Word, 0x39..=0x3b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
        val: emulator_types::RvData,
    ) -> Result<(), emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => {
                self.periph
                    .write_interrupt_state(InterruptStateReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 4) => {
                self.periph
                    .write_interrupt_enable(InterruptEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => {
                self.periph
                    .write_interrupt_test(InterruptTestReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => {
                self.periph.write_alert_test(AlertTestReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10) => {
                self.periph.write_control(ControlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x11..=0x13) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14) => {
                self.periph.write_status(StatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x15..=0x17) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x18) => {
                self.periph.write_configopts(ConfigoptsReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x19..=0x1b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                self.periph.write_csid(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                self.periph.write_command(CommandReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x28) => {
                self.periph.write_rxdata(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x29..=0x2b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x30) => {
                self.periph
                    .write_error_enable(ErrorEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x31..=0x33) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x34) => {
                self.periph
                    .write_error_status(ErrorStatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x35..=0x37) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x38) => {
                self.periph
                    .write_event_enable(EventEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x39..=0x3b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
