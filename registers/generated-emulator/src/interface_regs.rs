// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at c5d7a2917bc0cf0a27bed802a3664c0bf3d5bf8b
//
#[allow(unused_imports)]
use tock_registers::interfaces::{Readable, Writeable};
pub trait InterfaceRegsPeripheral {
    fn set_dma_ram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<caliptra_emu_bus::Ram>>) {}
    fn set_dma_rom_sram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<caliptra_emu_bus::Ram>>) {}
    fn register_event_channels(
        &mut self,
        _events_to_caliptra: std::sync::mpsc::Sender<caliptra_emu_bus::Event>,
        _events_from_caliptra: std::sync::mpsc::Receiver<caliptra_emu_bus::Event>,
        _events_to_mcu: std::sync::mpsc::Sender<caliptra_emu_bus::Event>,
        _events_from_mcu: std::sync::mpsc::Receiver<caliptra_emu_bus::Event>,
    ) {
    }
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_fpga_magic(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn read_fpga_version(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn read_control(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::interface_regs::bits::Control::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_control(
        &mut self,
        _val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::interface_regs::bits::Control::Register,
        >,
    ) {
    }
    fn read_status(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::interface_regs::bits::Status::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn read_arm_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_arm_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_itrng_divisor(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_itrng_divisor(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_cycle_count(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn read_generic_input_wires(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_generic_input_wires(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_generic_output_wires(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn read_cptra_obf_key(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_cptra_obf_key(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_cptra_csr_hmac_key(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_cptra_csr_hmac_key(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_cptra_obf_uds_seed(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_cptra_obf_uds_seed(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_cptra_obf_field_entropy(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_cptra_obf_field_entropy(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_lsu_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_lsu_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_ifu_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_ifu_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_dma_axi_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_dma_axi_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_soc_config_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_soc_config_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_sram_config_user(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_sram_config_user(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_mcu_reset_vector(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_mcu_reset_vector(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_mci_error(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::interface_regs::bits::MciError::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn read_mcu_config(
        &mut self,
    ) -> caliptra_emu_bus::ReadWriteRegister<
        u32,
        registers_generated::interface_regs::bits::McuConfig::Register,
    > {
        caliptra_emu_bus::ReadWriteRegister::new(0)
    }
    fn write_mcu_config(
        &mut self,
        _val: caliptra_emu_bus::ReadWriteRegister<
            u32,
            registers_generated::interface_regs::bits::McuConfig::Register,
        >,
    ) {
    }
    fn read_uds_seed_base_addr(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_uds_seed_base_addr(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_prod_debug_unlock_auth_pk_hash_reg_bank_offset(
        &mut self,
    ) -> caliptra_emu_types::RvData {
        0
    }
    fn write_prod_debug_unlock_auth_pk_hash_reg_bank_offset(
        &mut self,
        _val: caliptra_emu_types::RvData,
    ) {
    }
    fn read_num_of_prod_debug_unlock_auth_pk_hashes(&mut self) -> caliptra_emu_types::RvData {
        0
    }
    fn write_num_of_prod_debug_unlock_auth_pk_hashes(&mut self, _val: caliptra_emu_types::RvData) {}
    fn read_mci_generic_input_wires(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
    fn write_mci_generic_input_wires(&mut self, _val: caliptra_emu_types::RvData, _index: usize) {}
    fn read_mci_generic_output_wires(&mut self, _index: usize) -> caliptra_emu_types::RvData {
        0
    }
}
pub struct InterfaceRegsBus {
    pub periph: Box<dyn InterfaceRegsPeripheral>,
}
impl caliptra_emu_bus::Bus for InterfaceRegsBus {
    fn read(
        &mut self,
        size: caliptra_emu_types::RvSize,
        addr: caliptra_emu_types::RvAddr,
    ) -> Result<caliptra_emu_types::RvData, caliptra_emu_bus::BusError> {
        if addr & 0x3 != 0 || size != caliptra_emu_types::RvSize::Word {
            return Err(caliptra_emu_bus::BusError::LoadAddrMisaligned);
        }
        match addr {
            0..4 => Ok(self.periph.read_fpga_magic()),
            4..8 => Ok(self.periph.read_fpga_version()),
            8..0xc => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_control().reg.get(),
            )),
            0xc..0x10 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_status().reg.get(),
            )),
            0x10..0x14 => Ok(self.periph.read_arm_user()),
            0x14..0x18 => Ok(self.periph.read_itrng_divisor()),
            0x18..0x1c => Ok(self.periph.read_cycle_count()),
            0x30..0x38 => Ok(self
                .periph
                .read_generic_input_wires((addr as usize - 0x30) / 4)),
            0x38..0x40 => Ok(self
                .periph
                .read_generic_output_wires((addr as usize - 0x38) / 4)),
            0x40..0x60 => Ok(self.periph.read_cptra_obf_key((addr as usize - 0x40) / 4)),
            0x60..0xa0 => Ok(self
                .periph
                .read_cptra_csr_hmac_key((addr as usize - 0x60) / 4)),
            0xa0..0xe0 => Ok(self
                .periph
                .read_cptra_obf_uds_seed((addr as usize - 0xa0) / 4)),
            0xe0..0x100 => Ok(self
                .periph
                .read_cptra_obf_field_entropy((addr as usize - 0xe0) / 4)),
            0x100..0x104 => Ok(self.periph.read_lsu_user()),
            0x104..0x108 => Ok(self.periph.read_ifu_user()),
            0x108..0x10c => Ok(self.periph.read_dma_axi_user()),
            0x10c..0x110 => Ok(self.periph.read_soc_config_user()),
            0x110..0x114 => Ok(self.periph.read_sram_config_user()),
            0x114..0x118 => Ok(self.periph.read_mcu_reset_vector()),
            0x118..0x11c => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_mci_error().reg.get(),
            )),
            0x11c..0x120 => Ok(caliptra_emu_types::RvData::from(
                self.periph.read_mcu_config().reg.get(),
            )),
            0x120..0x124 => Ok(self.periph.read_uds_seed_base_addr()),
            0x124..0x128 => Ok(self
                .periph
                .read_prod_debug_unlock_auth_pk_hash_reg_bank_offset()),
            0x128..0x12c => Ok(self.periph.read_num_of_prod_debug_unlock_auth_pk_hashes()),
            0x12c..0x134 => Ok(self
                .periph
                .read_mci_generic_input_wires((addr as usize - 0x12c) / 4)),
            0x134..0x13c => Ok(self
                .periph
                .read_mci_generic_output_wires((addr as usize - 0x134) / 4)),
            _ => Err(caliptra_emu_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: caliptra_emu_types::RvSize,
        addr: caliptra_emu_types::RvAddr,
        val: caliptra_emu_types::RvData,
    ) -> Result<(), caliptra_emu_bus::BusError> {
        if addr & 0x3 != 0 || size != caliptra_emu_types::RvSize::Word {
            return Err(caliptra_emu_bus::BusError::StoreAddrMisaligned);
        }
        match addr {
            8..0xc => {
                self.periph
                    .write_control(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x10..0x14 => {
                self.periph.write_arm_user(val);
                Ok(())
            }
            0x14..0x18 => {
                self.periph.write_itrng_divisor(val);
                Ok(())
            }
            0x30..0x38 => {
                self.periph
                    .write_generic_input_wires(val, (addr as usize - 0x30) / 4);
                Ok(())
            }
            0x40..0x60 => {
                self.periph
                    .write_cptra_obf_key(val, (addr as usize - 0x40) / 4);
                Ok(())
            }
            0x60..0xa0 => {
                self.periph
                    .write_cptra_csr_hmac_key(val, (addr as usize - 0x60) / 4);
                Ok(())
            }
            0xa0..0xe0 => {
                self.periph
                    .write_cptra_obf_uds_seed(val, (addr as usize - 0xa0) / 4);
                Ok(())
            }
            0xe0..0x100 => {
                self.periph
                    .write_cptra_obf_field_entropy(val, (addr as usize - 0xe0) / 4);
                Ok(())
            }
            0x100..0x104 => {
                self.periph.write_lsu_user(val);
                Ok(())
            }
            0x104..0x108 => {
                self.periph.write_ifu_user(val);
                Ok(())
            }
            0x108..0x10c => {
                self.periph.write_dma_axi_user(val);
                Ok(())
            }
            0x10c..0x110 => {
                self.periph.write_soc_config_user(val);
                Ok(())
            }
            0x110..0x114 => {
                self.periph.write_sram_config_user(val);
                Ok(())
            }
            0x114..0x118 => {
                self.periph.write_mcu_reset_vector(val);
                Ok(())
            }
            0x11c..0x120 => {
                self.periph
                    .write_mcu_config(caliptra_emu_bus::ReadWriteRegister::new(val));
                Ok(())
            }
            0x120..0x124 => {
                self.periph.write_uds_seed_base_addr(val);
                Ok(())
            }
            0x124..0x128 => {
                self.periph
                    .write_prod_debug_unlock_auth_pk_hash_reg_bank_offset(val);
                Ok(())
            }
            0x128..0x12c => {
                self.periph
                    .write_num_of_prod_debug_unlock_auth_pk_hashes(val);
                Ok(())
            }
            0x12c..0x134 => {
                self.periph
                    .write_mci_generic_input_wires(val, (addr as usize - 0x12c) / 4);
                Ok(())
            }
            _ => Err(caliptra_emu_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
