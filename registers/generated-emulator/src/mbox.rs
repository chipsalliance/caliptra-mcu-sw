// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 2ec4914686d656467fae8ff40ee7da03ee6f5ec3
//
#[allow(unused_imports)]
use tock_registers::interfaces::{Readable, Writeable};
pub trait MboxPeripheral {
    fn set_dma_ram(&mut self, _ram: std::rc::Rc<std::cell::RefCell<emulator_bus::Ram>>) {}
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_lock(
        &mut self,
        _size: emulator_types::RvSize,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::mbox::bits::Lock::Register> {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn read_user(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData {
        0
    }
    fn read_cmd(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData {
        0
    }
    fn write_cmd(&mut self, _size: emulator_types::RvSize, _val: emulator_types::RvData) {}
    fn read_dlen(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData {
        0
    }
    fn write_dlen(&mut self, _size: emulator_types::RvSize, _val: emulator_types::RvData) {}
    fn read_datain(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData {
        0
    }
    fn write_datain(&mut self, _size: emulator_types::RvSize, _val: emulator_types::RvData) {}
    fn read_dataout(&mut self, _size: emulator_types::RvSize) -> emulator_types::RvData {
        0
    }
    fn write_dataout(&mut self, _size: emulator_types::RvSize, _val: emulator_types::RvData) {}
    fn read_execute(
        &mut self,
        _size: emulator_types::RvSize,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::mbox::bits::Execute::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_execute(
        &mut self,
        _size: emulator_types::RvSize,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::mbox::bits::Execute::Register,
        >,
    ) {
    }
    fn read_status(
        &mut self,
        _size: emulator_types::RvSize,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::mbox::bits::Status::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_status(
        &mut self,
        _size: emulator_types::RvSize,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::mbox::bits::Status::Register,
        >,
    ) {
    }
    fn read_unlock(
        &mut self,
        _size: emulator_types::RvSize,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::mbox::bits::Unlock::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_unlock(
        &mut self,
        _size: emulator_types::RvSize,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::mbox::bits::Unlock::Register,
        >,
    ) {
    }
    fn read_tap_mode(
        &mut self,
        _size: emulator_types::RvSize,
    ) -> emulator_bus::ReadWriteRegister<u32, registers_generated::mbox::bits::TapMode::Register>
    {
        emulator_bus::ReadWriteRegister::new(0)
    }
    fn write_tap_mode(
        &mut self,
        _size: emulator_types::RvSize,
        _val: emulator_bus::ReadWriteRegister<
            u32,
            registers_generated::mbox::bits::TapMode::Register,
        >,
    ) {
    }
}
pub struct MboxBus {
    pub periph: Box<dyn MboxPeripheral>,
}
impl emulator_bus::Bus for MboxBus {
    fn read(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
    ) -> Result<emulator_types::RvData, emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_lock(emulator_types::RvSize::Word)
                    .reg
                    .get(),
            )),
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (size, 4) => Ok(self.periph.read_user(size)),
            (_, 5..=7) => Err(emulator_bus::BusError::LoadAddrMisaligned),
            (size, 8) => Ok(self.periph.read_cmd(size)),
            (_, 9..=0xb) => Err(emulator_bus::BusError::LoadAddrMisaligned),
            (size, 0xc) => Ok(self.periph.read_dlen(size)),
            (_, 0xd..=0xf) => Err(emulator_bus::BusError::LoadAddrMisaligned),
            (size, 0x10) => Ok(self.periph.read_datain(size)),
            (_, 0x11..=0x13) => Err(emulator_bus::BusError::LoadAddrMisaligned),
            (size, 0x14) => Ok(self.periph.read_dataout(size)),
            (_, 0x15..=0x17) => Err(emulator_bus::BusError::LoadAddrMisaligned),
            (emulator_types::RvSize::Word, 0x18) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_execute(emulator_types::RvSize::Word)
                    .reg
                    .get(),
            )),
            (emulator_types::RvSize::Word, 0x19..=0x1b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_status(emulator_types::RvSize::Word)
                    .reg
                    .get(),
            )),
            (emulator_types::RvSize::Word, 0x1d..=0x1f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_unlock(emulator_types::RvSize::Word)
                    .reg
                    .get(),
            )),
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_tap_mode(emulator_types::RvSize::Word)
                    .reg
                    .get(),
            )),
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
        val: emulator_types::RvData,
    ) -> Result<(), emulator_bus::BusError> {
        match (size, addr) {
            (size, 8) => {
                self.periph.write_cmd(size, val);
                Ok(())
            }
            (_, 9..=0xb) => Err(emulator_bus::BusError::StoreAddrMisaligned),
            (size, 0xc) => {
                self.periph.write_dlen(size, val);
                Ok(())
            }
            (_, 0xd..=0xf) => Err(emulator_bus::BusError::StoreAddrMisaligned),
            (size, 0x10) => {
                self.periph.write_datain(size, val);
                Ok(())
            }
            (_, 0x11..=0x13) => Err(emulator_bus::BusError::StoreAddrMisaligned),
            (size, 0x14) => {
                self.periph.write_dataout(size, val);
                Ok(())
            }
            (_, 0x15..=0x17) => Err(emulator_bus::BusError::StoreAddrMisaligned),
            (emulator_types::RvSize::Word, 0x18) => {
                self.periph.write_execute(
                    emulator_types::RvSize::Word,
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x19..=0x1b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c) => {
                self.periph.write_status(
                    emulator_types::RvSize::Word,
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1d..=0x1f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                self.periph.write_unlock(
                    emulator_types::RvSize::Word,
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                self.periph.write_tap_mode(
                    emulator_types::RvSize::Word,
                    emulator_bus::ReadWriteRegister::new(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
