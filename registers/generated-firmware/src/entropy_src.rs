// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at a621fff9df7015821eda6f7f73265fef74a01375
//
pub const ENTROPY_SRC_ADDR: u32 = 0x2000_9000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub AdaptpHiThresholds [
                /// This is the threshold size for the adaptive proportion health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the adaptive proportion health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub AdaptpHiWatermarks [
                /// High watermark value of the adaptive proportion test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the adaptive proportion test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub AdaptpLoThresholds [
                /// This is the threshold size for the adaptive proportion health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the adaptive proportion health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub AdaptpLoWatermarks [
                /// Low watermark value of the adaptive proportion test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// Low watermark value of the adaptive proportion test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub AlertFailCounts [
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                RepcntFailCount OFFSET(4) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                AdaptpHiFailCount OFFSET(8) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                AdaptpLoFailCount OFFSET(12) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                BucketFailCount OFFSET(16) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                MarkovHiFailCount OFFSET(20) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                MarkovLoFailCount OFFSET(24) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                RepcntsFailCount OFFSET(28) NUMBITS(4) [],
            ],
            pub AlertSummaryFailCounts [
                /// This field will hold a running count of
                /// the total alert count, which is a sum of all of the other
                /// counters in the !!ALERT_FAIL_COUNTS register.
                /// It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                AnyFailCount OFFSET(0) NUMBITS(16) [],
            ],
            pub AlertTest [
                /// Write 1 to trigger one alert event of this kind.
                RecovAlert OFFSET(0) NUMBITS(1) [],
                /// Write 1 to trigger one alert event of this kind.
                FatalAlert OFFSET(1) NUMBITS(1) [],
            ],
            pub AlertThreshold [
                /// This is the threshold size that will signal an alert when
                /// value is reached. A value of zero will disable alerts.
                /// The default value is 2.
                AlertThreshold OFFSET(0) NUMBITS(16) [],
                /// This should be set to the value above, but inverted.
                AlertThresholdInv OFFSET(16) NUMBITS(16) [],
            ],
            pub BucketHiWatermarks [
                /// High watermark value of the bucket test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the bucket test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub BucketThresholds [
                /// This is the threshold size for the bucket health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the bucket health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub Conf [
                /// Setting this field to kMultiBitBool4True will enable FIPS qualified entropy to be
                /// generated.
                FipsEnable OFFSET(0) NUMBITS(4) [],
                /// Setting this field to kMultiBitBool4True will enable reading entropy values from the
                /// ENTROPY_DATA register. This function also requires that the otp_en_entropy_src_fw_read
                /// input vector is set to the enable encoding.
                EntropyDataRegEnable OFFSET(4) NUMBITS(4) [],
                /// This field controls the scope (either by-line or by-sum) of the health checks.
                /// If set to kMultiBitBool4True, the Adaptive Proportion and Markov Tests will accumulate all
                /// RNG input lines into a single score, and thresholds will be applied to the sum all
                /// the entropy input lines.  If set to kMultiBitBool4False, the RNG input lines are all scored
                /// individually.  A statistical deviation in any one input line, be it due to
                /// coincidence or failure, will force rejection of the sample, and count toward the
                /// total alert count.
                ThresholdScope OFFSET(12) NUMBITS(4) [],
                /// Setting this field to kMultiBitBool4True enables the single RNG bit mode, where only
                /// one bit is sampled.
                RngBitEnable OFFSET(20) NUMBITS(4) [],
                /// When the above bit iset, this field selects which bit from the RNG bus will
                /// be processed when in single RNG bit mode.
                /// This two bit field selects the RNG bit stream:
                /// 0b00: RNG bit 0
                /// 0b01: RNG bit 1
                /// 0b10: RNG bit 2
                /// 0b11: RNG bit 3
                RngBitSel OFFSET(24) NUMBITS(2) [],
            ],
            pub DebugStatus [
                /// This is the depth of the entropy source FIFO.
                EntropyFifoDepth OFFSET(0) NUMBITS(3) [],
                /// This is the SHA3 finite state machine current state.
                Sha3Fsm OFFSET(3) NUMBITS(3) [],
                /// This is the SHA3 block processed signal current state.
                Sha3BlockPr OFFSET(6) NUMBITS(1) [],
                /// This is the SHA3 squeezing signal current state.
                Sha3Squeezing OFFSET(7) NUMBITS(1) [],
                /// This is the SHA3 absorbed signal current state.
                Sha3Absorbed OFFSET(8) NUMBITS(1) [],
                /// This is a logic-or of all of the SHA3 error signals.
                Sha3Err OFFSET(9) NUMBITS(1) [],
                /// The entropy_src main state machine is in the idle state.
                MainSmIdle OFFSET(16) NUMBITS(1) [],
                /// The entropy_src main state machine is in the boot phase done state.
                MainSmBootDone OFFSET(17) NUMBITS(1) [],
            ],
            pub EntropyControl [
                /// Setting this field to kMultiBitBool4True routes the generated entropy value to the ENTROPY_DATA
                /// register to be read by firmware. When this field is kMultiBitBool4False, the generated
                /// entropy will be forwarded out of this module to the hardware interface.
                EsRoute OFFSET(0) NUMBITS(4) [],
                /// Setting this field to kMultiBitBool4True will bypass the conditioning logic and bring raw entropy
                /// data to the ENTROPY_DATA register. When kMultiBitBool4False, FIPS compliant entropy
                /// will be brought the ENTROPY_DATA register, after being conditioned.
                EsType OFFSET(4) NUMBITS(4) [],
            ],
            pub EntropyInterruptEnable [
                /// Enable interrupt when es_entropy_valid is set.
                EsEntropyValid OFFSET(0) NUMBITS(1) [],
                /// Enable interrupt when es_health_test_failed is set.
                EsHealthTestFailed OFFSET(1) NUMBITS(1) [],
                /// Enable interrupt when es_observe_fifo_ready is set.
                EsObserveFifoReady OFFSET(2) NUMBITS(1) [],
                /// Enable interrupt when es_fatal_err is set.
                EsFatalErr OFFSET(3) NUMBITS(1) [],
            ],
            pub ErrCode [
                /// This bit will be set to one when an error has been detected for the
                /// esrng FIFO. The type of error is reflected in the type status
                /// bits (bits 28 through 30 of this register).
                /// This bit will stay set until the next reset.
                SfifoEsrngErr OFFSET(0) NUMBITS(1) [],
                /// This bit will be set to one when an error has been detected for the
                /// observe FIFO. The type of error is reflected in the type status
                /// bits (bits 28 through 30 of this register).
                /// This bit will stay set until the next reset.
                SfifoObserveErr OFFSET(1) NUMBITS(1) [],
                /// This bit will be set to one when an error has been detected for the
                /// esfinal FIFO. The type of error is reflected in the type status
                /// bits (bits 28 through 30 of this register).
                /// This bit will stay set until the next reset.
                SfifoEsfinalErr OFFSET(2) NUMBITS(1) [],
                /// This bit will be set to one when an illegal state has been detected for the
                /// ES ack stage state machine. This error will signal a fatal alert, and also
                /// an interrupt if enabled.
                /// This bit will stay set until the next reset.
                EsAckSmErr OFFSET(20) NUMBITS(1) [],
                /// This bit will be set to one when an illegal state has been detected for the
                /// ES main stage state machine. This error will signal a fatal alert, and also
                /// an interrupt if enabled.
                /// This bit will stay set until the next reset.
                EsMainSmErr OFFSET(21) NUMBITS(1) [],
                /// This bit will be set to one when a hardened counter has detected an error
                /// condition. This error will signal a fatal alert, and also
                /// an interrupt if enabled.
                /// This bit will stay set until the next reset.
                EsCntrErr OFFSET(22) NUMBITS(1) [],
                /// This bit will be set to one when a SHA3 state error has been detected.
                /// This error will signal a fatal alert, and also an interrupt if enabled.
                /// This bit will stay set until the next reset.
                Sha3StateErr OFFSET(23) NUMBITS(1) [],
                /// This bit will be set to one when a SHA3_RST_STORAGE_ERR signal being
                /// active has been detected.
                /// This error will signal a fatal alert, and also an interrupt if enabled.
                /// This bit will stay set until the next reset.
                Sha3RstStorageErr OFFSET(24) NUMBITS(1) [],
                /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
                /// this register) are asserted as a result of an error pulse generated from
                /// any full FIFO that has been recieved a write pulse.
                /// This bit will stay set until the next reset.
                FifoWriteErr OFFSET(28) NUMBITS(1) [],
                /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
                /// this register) are asserted as a result of an error pulse generated from
                /// any empty FIFO that has recieved a read pulse.
                /// This bit will stay set until the next reset.
                FifoReadErr OFFSET(29) NUMBITS(1) [],
                /// This bit will be set to one when any of the source bits (bits 0 through 1 of this
                /// this register) are asserted as a result of an error pulse generated from
                /// any FIFO where both the empty and full status bits are set.
                /// This bit will stay set until the next reset.
                FifoStateErr OFFSET(30) NUMBITS(1) [],
            ],
            pub ErrCodeTest [
                /// Setting this field will set the bit number for which an error
                /// will be forced in the hardware. This bit number is that same one
                /// found in the !!ERR_CODE register. The action of writing this
                /// register will force an error pulse. The sole purpose of this
                /// register is to test that any error properly propagates to either
                /// an interrupt or an alert.
                ErrCodeTest OFFSET(0) NUMBITS(5) [],
            ],
            pub ExthtFailCounts [
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                ExthtHiFailCount OFFSET(0) NUMBITS(4) [],
                /// This field will hold a running count of test failures that
                /// contribute to the total alert count. It will be reset after every
                /// passing test sequence. If an alert is signaled, this value
                /// will persist until it is cleared.
                ExthtLoFailCount OFFSET(4) NUMBITS(4) [],
            ],
            pub ExthtHiThresholds [
                /// This is the threshold size for the external health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the external health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub ExthtHiWatermarks [
                /// High watermark value of the external health test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the external health test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub ExthtLoThresholds [
                /// This is the threshold size for the external health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the external health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub ExthtLoWatermarks [
                /// Low watermark value of the external health test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// Low watermark value of the external health test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub FwOvControl [
                /// Setting this field to kMultiBitBool4True will put the entropy flow in firmware override mode.
                /// In this mode, firmware can monitor the post-health test entropy by reading
                /// the observe FIFO. This function also requires that the otp_en_entropy_src_fw_over
                /// input vector is set to the enable encoding.
                FwOvMode OFFSET(0) NUMBITS(4) [],
                /// Setting this field to kMultiBitBool4True will switch the input into the pre-conditioner
                /// packer FIFO. Firmware can directly write into the packer FIFO, enabling
                /// the ability to insert entropy bits back into the hardware flow. Firmware
                /// can read data from the health check packer FIFO, then do optional health
                /// checks or optional conditioning, then insert the results back into the flow.
                /// Also, the !!FW_OV_CONTROL.FW_OV_MODE bit must be set.
                FwOvEntropyInsert OFFSET(4) NUMBITS(4) [],
            ],
            pub FwOvRdFifoOverflow [
                /// This bit is set by hardware whenever RNG data is lost due to an overflow condition
                /// in the Observe FIFO. The RNG data rate is slow enough that firmware should always
                /// be able to keep up. This register meanwhile provides an additional check to confirm
                /// that bytes read from the !!FW_OV_RD_DATA register represent contiguous RNG samples.
                /// If an overflow event occurs, this bit is cleared by hardware as soon as the FIFO is emptied.
                FwOvRdFifoOverflow OFFSET(0) NUMBITS(1) [],
            ],
            pub FwOvSha3Start [
                /// Setting this field to kMultiBitBool4True will instruct the ENTROPY_SRC main state machine
                /// to start the SHA3 process and be ready to accept entropy data. This field should
                /// be set prior to writting the FW_OV_WR_DATA register. Once all data has been written,
                /// this field should be set to kMultiBitBool4False. Once that happened, the SHA3 block will finish
                /// processing and push the result into the ESFINAL FIFO.
                ///
                /// Note that clearing this bit to kMultiBitBool4False while there is still unprocessed
                /// entropy in the !!FW_OV_WR_DATA will start the SHA3 engine before data can be added
                /// to the input message, and will also signal a recoverable alert in
                /// !!RECOV_ALERT_STS.ES_FW_OV_DISABLE_ALERT.  To avoid this, check that
                /// !!FW_OV_WR_FIFO_FULL is clear before setting this field to kMultiBitBool4False.
                FwOvInsertStart OFFSET(0) NUMBITS(4) [],
            ],
            pub FwOvWrFifoFull [
                /// "When this bit is clear, writes to the FW_OV_WR_DATA register are allowed.
                /// If this bit is set, it is the equivalent to a FIFO full condition, and writes
                /// to the FW_OV_WR_DATA register must be delayed until this bit is reset.
                FwOvWrFifoFull OFFSET(0) NUMBITS(1) [],
            ],
            pub HealthTestWindows [
                /// This is the window size for all health tests. This value is used in normal mode
                /// when entropy is being tested in FIPS/CC compliance mode.
                /// The default value is (2048 bits * 1 clock/4 bits);
                FipsWindow OFFSET(0) NUMBITS(16) [],
                /// This is the window size for all health tests when running in bypass mode. This mode
                /// is active after reset for the first and only test run, or when this mode is
                /// programmed by firmware.
                /// The default value is (384 bits * 1 clock/4 bits);
                ///
                /// Note that currently only a window size of 384 is supported and tested (this
                /// corresponds to the register default value 0x60). Do not use any other values,
                /// unless you know what you are doing.
                BypassWindow OFFSET(16) NUMBITS(16) [],
            ],
            pub InterruptState [
                /// Asserted when entropy source bits are available.
                EsEntropyValid OFFSET(0) NUMBITS(1) [],
                /// Asserted when the alert count has been met.
                EsHealthTestFailed OFFSET(1) NUMBITS(1) [],
                /// Asserted when the observe FIFO has filled to the threshold level.
                EsObserveFifoReady OFFSET(2) NUMBITS(1) [],
                /// Asserted when a FIFO error occurs, or if an illegal state machine state is reached.
                EsFatalErr OFFSET(3) NUMBITS(1) [],
            ],
            pub InterruptTest [
                /// Write 1 to force es_entropy_valid to 1.
                EsEntropyValid OFFSET(0) NUMBITS(1) [],
                /// Write 1 to force es_health_test_failed to 1.
                EsHealthTestFailed OFFSET(1) NUMBITS(1) [],
                /// Write 1 to force es_observe_fifo_ready to 1.
                EsObserveFifoReady OFFSET(2) NUMBITS(1) [],
                /// Write 1 to force es_fatal_err to 1.
                EsFatalErr OFFSET(3) NUMBITS(1) [],
            ],
            pub MainSmState [
                /// This is the state of the ENTROPY_SRC main state machine.
                /// See the RTL file `entropy_src_main_sm` for the meaning of the values.
                MainSmState OFFSET(0) NUMBITS(9) [],
            ],
            pub MarkovHiThresholds [
                /// This is the threshold size for the Markov health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the Markov health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub MarkovHiWatermarks [
                /// High watermark value of the Markov test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the Markov test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub MarkovLoThresholds [
                /// This is the threshold size for the Markov health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the Markov health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is greater than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub MarkovLoWatermarks [
                /// Low watermark value of the Markov test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// Low watermark value of the Markov test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub MeRegwen [
                /// When true, the !!MODULE_ENABLE register can be modified.
                /// When false, it becomes read-only.
                MeRegwen OFFSET(0) NUMBITS(1) [],
            ],
            pub ModuleEnable [
                /// Setting this field to kMultiBitBool4True will enable the ENTROPY_SRC module. Setting
                /// this field to kMultiBitBool4False will effectively reset the module. The modules of
                /// the entropy complex may only be enabled and disabled in a specific order, see
                /// Programmers Guide for details.
                ModuleEnable OFFSET(0) NUMBITS(4) [],
            ],
            pub ObserveFifoDepth [
                /// This field will hold the current depth of the Observe FIFO.
                ObserveFifoDepth OFFSET(0) NUMBITS(7) [],
            ],
            pub ObserveFifoThresh [
                /// This field will set the threshold that the depth of the Observe FIFO
                /// will be compared with when setting the interrupt status bit.
                /// Note: a value of zero is reserved and not to be used.
                ObserveFifoThresh OFFSET(0) NUMBITS(7) [],
            ],
            pub RecovAlertSts [
                /// This bit is set when the FIPS_ENABLE field in the !!CONF register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                FipsEnableFieldAlert OFFSET(0) NUMBITS(1) [],
                /// This bit is set when the ENTROPY_DATA_REG_ENABLE field in the !!CONF register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                EntropyDataRegEnFieldAlert OFFSET(1) NUMBITS(1) [],
                /// This bit is set when the MODULE_ENABLE field in the !!MODULE_ENABLE register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                ModuleEnableFieldAlert OFFSET(2) NUMBITS(1) [],
                /// This bit is set when the THRESHOLD_SCOPE field in the !!CONF register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                ThresholdScopeFieldAlert OFFSET(3) NUMBITS(1) [],
                /// This bit is set when the RNG_BIT_ENABLE field in the !!CONF register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                RngBitEnableFieldAlert OFFSET(5) NUMBITS(1) [],
                /// This bit is set when the FW_OV_SHA3_START field in the !!FW_OV_SHA3_START register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                FwOvSha3StartFieldAlert OFFSET(7) NUMBITS(1) [],
                /// This bit is set when the FW_OV_MODE field in the !!FW_OV_CONTROL register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                FwOvModeFieldAlert OFFSET(8) NUMBITS(1) [],
                /// This bit is set when the FW_OV_ENTROPY_INSERT field in the !!FW_OV_CONTROL register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                FwOvEntropyInsertFieldAlert OFFSET(9) NUMBITS(1) [],
                /// This bit is set when the ES_ROUTE field in the !!ENTROPY_CONTROL register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                EsRouteFieldAlert OFFSET(10) NUMBITS(1) [],
                /// This bit is set when the ES_TYPE field in the !!ENTROPY_CONTROL register is set to
                /// a value other than kMultiBitBool4False or kMultiBitBool4True.
                /// Writing a zero resets this status bit.
                EsTypeFieldAlert OFFSET(11) NUMBITS(1) [],
                /// This bit is set when the main state machine detects a threshhold failure state.
                /// Writing a zero resets this status bit.
                EsMainSmAlert OFFSET(12) NUMBITS(1) [],
                /// This bit is set when the interal entropy bus value is equal to the prior
                /// valid value on the bus, indicating a possible attack.
                /// Writing a zero resets this status bit.
                EsBusCmpAlert OFFSET(13) NUMBITS(1) [],
                /// This bit is set when the !!ALERT_THRESHOLD register is not configured properly.
                /// The upper field must be the exact inverse of the lower field.
                /// Writing a zero resets this status bit.
                EsThreshCfgAlert OFFSET(14) NUMBITS(1) [],
                /// This bit is set when the packer FIFO has been written but was full at the time,
                /// and in both FW_OV_MODE and FW_OV_ENTROPY_INSERT modes.
                /// This alert would normally be the result of not monitoring the !!FW_OV_WR_FIFO_FULL
                /// register before each write to the !!FW_OV_WR_DATA register.
                /// Writing a zero resets this status bit.
                EsFwOvWrAlert OFFSET(15) NUMBITS(1) [],
                /// This bit is set when !!FW_OV_SHA3_START has been set to MuBi4 False, without
                /// waiting for the FW_OV packer FIFO to clear.  The final entropy entry in the FIFO
                /// will not be included in the SHA3 digest. (Rather it will be added to the
                /// subsequent SHA3 digest.) To avoid this alert, monitor !!FW_OV_WR_FIFO_FULL before
                /// clearing !!FW_OV_SHA3_START. This alert only applies when both FW_OV_MODE and
                /// FW_OV_ENTROPY_INSERT are set to MuBi4True.
                /// Writing a zero resets this status bit.
                EsFwOvDisableAlert OFFSET(16) NUMBITS(1) [],
            ],
            pub Regwen [
                /// This read-only write enable bit will allow write access
                /// to control and theshold registers that are associated with this bit,
                /// but only when the MODULE_ENABLE field is set to kMultiBitBool4False and the
                /// SW_REGUPD write enable bit is set to true.
                /// When read as false, these registers become read-only.
                Regwen OFFSET(0) NUMBITS(1) [],
            ],
            pub RepcntsHiWatermarks [
                /// High watermark value of the REPCNTS test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the REPCNTS test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub RepcntsThresholds [
                /// This is the threshold size for the repetition count symbol health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the repetition count symbol health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub RepcntHiWatermarks [
                /// High watermark value of the REPCNT test in FIPS mode.
                FipsWatermark OFFSET(0) NUMBITS(16) [],
                /// High watermark value of the REPCNT test in bypass mode.
                BypassWatermark OFFSET(16) NUMBITS(16) [],
            ],
            pub RepcntThresholds [
                /// This is the threshold size for the repetition count health test.
                /// This value is used in normal mode when entropy is being tested in
                /// FIPS/CC compliance mode.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                FipsThresh OFFSET(0) NUMBITS(16) [],
                /// This is the threshold size for the repetition count health test
                /// running in bypass mode. This mode is active after reset for the
                /// first and only test run, or when this mode is programmed by firmware.
                /// This register must be written before the module is enabled.
                /// Writing to this register will only update the register if the
                /// written value is less than the current value of this register.
                /// A read from this register always reflects the current value.
                BypassThresh OFFSET(16) NUMBITS(16) [],
            ],
            pub Rev [
                /// Read of this register shows the ABI of this block.
                AbiRevision OFFSET(0) NUMBITS(8) [],
                /// Read of this register shows the revision of this block.
                HwRevision OFFSET(8) NUMBITS(8) [],
                /// Read of this register shows the type of chip using this block.
                ChipType OFFSET(16) NUMBITS(8) [],
            ],
            pub SwRegupd [
                /// When this bit true and the MODULE_ENABLE field is false,
                /// the REGWEN write enable bit read as true, and is distributed to
                /// all associated control and threshold registers.
                /// When false, these registers become read-only.
                SwRegupd OFFSET(0) NUMBITS(1) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub EntropySrc {
            (0x0 => pub interrupt_state: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::InterruptState::Register>),
            (0x4 => pub entropy_interrupt_enable: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::EntropyInterruptEnable::Register>),
            (0x8 => pub interrupt_test: tock_registers::registers::WriteOnly<u32, crate::entropy_src::bits::InterruptTest::Register>),
            (0xc => pub alert_test: tock_registers::registers::WriteOnly<u32, crate::entropy_src::bits::AlertTest::Register>),
            (0x10 => pub me_regwen: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::MeRegwen::Register>),
            (0x14 => pub sw_regupd: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::SwRegupd::Register>),
            (0x18 => pub regwen: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::Regwen::Register>),
            (0x1c => pub rev: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::Rev::Register>),
            (0x20 => pub module_enable: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::ModuleEnable::Register>),
            (0x24 => pub conf: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::Conf::Register>),
            (0x28 => pub entropy_control: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::EntropyControl::Register>),
            (0x2c => pub entropy_data: tock_registers::registers::ReadOnly<u32>),
            (0x30 => pub health_test_windows: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::HealthTestWindows::Register>),
            (0x34 => pub repcnt_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::RepcntThresholds::Register>),
            (0x38 => pub repcnts_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::RepcntsThresholds::Register>),
            (0x3c => pub adaptp_hi_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::AdaptpHiThresholds::Register>),
            (0x40 => pub adaptp_lo_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::AdaptpLoThresholds::Register>),
            (0x44 => pub bucket_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::BucketThresholds::Register>),
            (0x48 => pub markov_hi_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::MarkovHiThresholds::Register>),
            (0x4c => pub markov_lo_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::MarkovLoThresholds::Register>),
            (0x50 => pub extht_hi_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::ExthtHiThresholds::Register>),
            (0x54 => pub extht_lo_thresholds: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::ExthtLoThresholds::Register>),
            (0x58 => pub repcnt_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::RepcntHiWatermarks::Register>),
            (0x5c => pub repcnts_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::RepcntsHiWatermarks::Register>),
            (0x60 => pub adaptp_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::AdaptpHiWatermarks::Register>),
            (0x64 => pub adaptp_lo_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::AdaptpLoWatermarks::Register>),
            (0x68 => pub extht_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::ExthtHiWatermarks::Register>),
            (0x6c => pub extht_lo_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::ExthtLoWatermarks::Register>),
            (0x70 => pub bucket_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::BucketHiWatermarks::Register>),
            (0x74 => pub markov_hi_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::MarkovHiWatermarks::Register>),
            (0x78 => pub markov_lo_watermarks: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::MarkovLoWatermarks::Register>),
            (0x7c => pub repcnt_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x80 => pub repcnts_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x84 => pub adaptp_hi_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x88 => pub adaptp_lo_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x8c => pub bucket_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x90 => pub markov_hi_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x94 => pub markov_lo_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x98 => pub extht_hi_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0x9c => pub extht_lo_total_fails: tock_registers::registers::ReadOnly<u32>),
            (0xa0 => pub alert_threshold: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::AlertThreshold::Register>),
            (0xa4 => pub alert_summary_fail_counts: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::AlertSummaryFailCounts::Register>),
            (0xa8 => pub alert_fail_counts: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::AlertFailCounts::Register>),
            (0xac => pub extht_fail_counts: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::ExthtFailCounts::Register>),
            (0xb0 => pub fw_ov_control: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::FwOvControl::Register>),
            (0xb4 => pub fw_ov_sha3_start: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::FwOvSha3Start::Register>),
            (0xb8 => pub fw_ov_wr_fifo_full: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::FwOvWrFifoFull::Register>),
            (0xbc => pub fw_ov_rd_fifo_overflow: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::FwOvRdFifoOverflow::Register>),
            (0xc0 => pub fw_ov_rd_data: tock_registers::registers::ReadOnly<u32>),
            (0xc4 => pub fw_ov_wr_data: tock_registers::registers::WriteOnly<u32>),
            (0xc8 => pub observe_fifo_thresh: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::ObserveFifoThresh::Register>),
            (0xcc => pub observe_fifo_depth: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::ObserveFifoDepth::Register>),
            (0xd0 => pub debug_status: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::DebugStatus::Register>),
            (0xd4 => pub recov_alert_sts: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::RecovAlertSts::Register>),
            (0xd8 => pub err_code: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::ErrCode::Register>),
            (0xdc => pub err_code_test: tock_registers::registers::ReadWrite<u32, crate::entropy_src::bits::ErrCodeTest::Register>),
            (0xe0 => pub main_sm_state: tock_registers::registers::ReadOnly<u32, crate::entropy_src::bits::MainSmState::Register>),
            (0xe4 => @END),
        }
    }
}
