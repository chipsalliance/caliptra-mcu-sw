// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-rtl repo at 9f80a2bebb755233696929bf1da5ca0b90eba9a1
// , caliptra-ss repo at 9911c2b0e4bac9e4b48f6c2155c86cb116159734
// , and i3c-core repo at d5c715103f529ade0e5d375a53c5692daaa9c54b
//
#![allow(clippy::erasing_op)]
#![allow(clippy::identity_op)]
/// A zero-sized type that represents ownership of this
/// peripheral, used to get access to a Register lock. Most
/// programs create one of these in unsafe code near the top of
/// main(), and pass it to the driver responsible for managing
/// all access to the hardware.
pub struct MciCtrl {
    _priv: (),
}
impl MciCtrl {
    pub const PTR: *mut u32 = 0x20050000 as *mut u32;
    /// # Safety
    ///
    /// Caller must ensure that all concurrent use of this
    /// peripheral in the firmware is done so in a compatible
    /// way. The simplest way to enforce this is to only call
    /// this function once.
    #[inline(always)]
    pub unsafe fn new() -> Self {
        Self { _priv: () }
    }
    /// Returns a register block that can be used to read
    /// registers from this peripheral, but cannot write.
    #[inline(always)]
    pub fn regs(&self) -> RegisterBlock<ureg::RealMmio> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
    /// Return a register block that can be used to read and
    /// write this peripheral's registers.
    #[inline(always)]
    pub fn regs_mut(&mut self) -> RegisterBlock<ureg::RealMmioMut> {
        RegisterBlock {
            ptr: Self::PTR,
            mmio: core::default::Default::default(),
        }
    }
}
#[derive(Clone, Copy)]
pub struct RegisterBlock<TMmio: ureg::Mmio + core::borrow::Borrow<TMmio>> {
    ptr: *mut u32,
    mmio: TMmio,
}
impl<TMmio: ureg::Mmio + core::default::Default> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new(ptr: *mut u32) -> Self {
        Self {
            ptr,
            mmio: core::default::Default::default(),
        }
    }
}
impl<TMmio: ureg::Mmio> RegisterBlock<TMmio> {
    /// # Safety
    ///
    /// The caller is responsible for ensuring that ptr is valid for
    /// volatile reads and writes at any of the offsets in this register
    /// block.
    #[inline(always)]
    pub unsafe fn new_with_mmio(ptr: *mut u32, mmio: TMmio) -> Self {
        Self { ptr, mmio }
    }
    /// Reports configuration and build options for MCI.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RO
    /// [br]SoC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::CapabilitiesReadVal`]; Write value: [`mci_ctrl::regs::CapabilitiesWriteVal`]
    #[inline(always)]
    pub fn capabilities(&self) -> ureg::RegRef<crate::mci_ctrl::meta::Capabilities, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// HW revision ID for Manufacturer Control components (MCU & MCI) that matches the official
    /// final release milestone of Caliptra Subsystem.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::HwRevIdReadVal`]; Write value: [`mci_ctrl::regs::HwRevIdWriteVal`]
    #[inline(always)]
    pub fn hw_rev_id(&self) -> ureg::RegRef<crate::mci_ctrl::meta::HwRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU ROM revision ID
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rom_rev_id(&self) -> ureg::RegRef<crate::mci_ctrl::meta::RomRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(8 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// MCU FW revision ID
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_rev_id(&self) -> ureg::RegRef<crate::mci_ctrl::meta::FwRevId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the boot status.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    /// [br]TAP Access [in debug/manuf mode]: RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn boot_status(&self) -> ureg::RegRef<crate::mci_ctrl::meta::BootStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x20 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Reports the status of the firmware flows.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::FlowStatusReadVal`]; Write value: [`mci_ctrl::regs::FlowStatusWriteVal`]
    #[inline(always)]
    pub fn flow_status(&self) -> ureg::RegRef<crate::mci_ctrl::meta::FlowStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x24 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates to ROM the originating cause for the PC to be reset to 0.
    /// Only reset during cold-boot (sticky).
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::ResetReasonReadVal`]; Write value: [`mci_ctrl::regs::ResetReasonWriteVal`]
    #[inline(always)]
    pub fn reset_reason(&self) -> ureg::RegRef<crate::mci_ctrl::meta::ResetReason, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x28 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only an MCI reset will clear the fatal error interrupt.
    /// [br]Caliptra Access: RW1C
    /// [br]MCU Access:      RW1C
    /// [br]SOC Access:      RW1C
    ///
    /// Read value: [`mci_ctrl::regs::HwErrorReadVal`]; Write value: [`mci_ctrl::regs::HwErrorWriteVal`]
    #[inline(always)]
    pub fn hw_error_fatal(&self) -> ureg::RegRef<crate::mci_ctrl::meta::HwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x40 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal hardware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW1C
    /// [br]MCU Access:      RW1C
    /// [br]SOC Access:      RW1C
    ///
    /// Read value: [`mci_ctrl::regs::HwErrorReadVal`]; Write value: [`mci_ctrl::regs::HwErrorWriteVal`]
    #[inline(always)]
    pub fn hw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::mci_ctrl::meta::HwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x44 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, clearing
    /// the bit in this register will not cause the interrupt to deassert.
    /// Only an MCI reset will clear the fatal error interrupt.
    /// [br]Caliptra Access: RW
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_error_fatal(&self) -> ureg::RegRef<crate::mci_ctrl::meta::FwErrorFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x48 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Indicates non-fatal firmware error. Assertion of any bit in this
    /// register results in the assertion of the SoC interrupt pin,
    /// mci_error_non_fatal, unless that bit is masked using the internal
    /// mask register. After the output interrupt is asserted, any
    /// change by firmware that results in all set non-fatal errors
    /// being masked will immediately deassert the interrupt output. This means
    /// that firmware may cause the mci_error_non_fatal signal to deassert by
    /// writing to any of these registers, if the write results in all error
    /// bits being cleared or masked:
    /// [br][list]
    /// [br] [*] HW_ERROR_NON_FATAL
    /// [br] [*] FW_ERROR_NON_FATAL
    /// [br] [*] hw_error_non_fatal_mask
    /// [br] [*] fw_error_non_fatal_mask
    /// [/list]
    /// [br]Caliptra Access: RW
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn fw_error_non_fatal(
        &self,
    ) -> ureg::RegRef<crate::mci_ctrl::meta::FwErrorNonFatal, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x4c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 enable register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SoC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::WdtTimer1EnReadVal`]; Write value: [`mci_ctrl::regs::WdtTimer1EnWriteVal`]
    #[inline(always)]
    pub fn wdt_timer1_en(&self) -> ureg::RegRef<crate::mci_ctrl::meta::WdtTimer1En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x80 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 control register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::WdtTimer1CtrlReadVal`]; Write value: [`mci_ctrl::regs::WdtTimer1CtrlWriteVal`]
    #[inline(always)]
    pub fn wdt_timer1_ctrl(&self) -> ureg::RegRef<crate::mci_ctrl::meta::WdtTimer1Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x84 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer1 timeout register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_timer1_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::WdtTimer1TimeoutPeriod, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x88 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 enable register. Note: Setting this to 1 will disable the default cascaded mode and will have both timers count independently.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::WdtTimer2EnReadVal`]; Write value: [`mci_ctrl::regs::WdtTimer2EnWriteVal`]
    #[inline(always)]
    pub fn wdt_timer2_en(&self) -> ureg::RegRef<crate::mci_ctrl::meta::WdtTimer2En, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x90 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 control register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::WdtTimer2CtrlReadVal`]; Write value: [`mci_ctrl::regs::WdtTimer2CtrlWriteVal`]
    #[inline(always)]
    pub fn wdt_timer2_ctrl(&self) -> ureg::RegRef<crate::mci_ctrl::meta::WdtTimer2Ctrl, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x94 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer2 timeout register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_timer2_timeout_period(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::WdtTimer2TimeoutPeriod, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x98 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Watchdog timer status register
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::CptraWdtStatusReadVal`]; Write value: [`mci_ctrl::regs::CptraWdtStatusWriteVal`]
    #[inline(always)]
    pub fn cptra_wdt_status(&self) -> ureg::RegRef<crate::mci_ctrl::meta::CptraWdtStatus, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xa0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// SOC provided count in cycles for WDT1 timeout.
    /// [br]Caliptra Access: RW
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RW
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn wdt_cfg(&self) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::WdtCfg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0xb0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Provides the clock period of the system clock.
    /// Used to standardize the RISC-V Standard MTIME count register.
    /// Clock Period is indicated as an integer number of picoseconds.
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mcu_timer_config(&self) -> ureg::RegRef<crate::mci_ctrl::meta::McuTimerConfig, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci_ctrl::regs::McuClkGatingEnAnon84ReadVal`]; Write value: [`mci_ctrl::regs::McuClkGatingEnAnon84WriteVal`]
    #[inline(always)]
    pub fn mcu_clk_gating_en(&self) -> ureg::RegRef<crate::mci_ctrl::meta::McuClkGatingEn, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0xc4 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Used by Caliptra to request an MCU reset to facilitate firmware updates.
    /// Reset request is the first step in a handshake protocol between Caliptra and
    /// the MCU before the MCU is reset and executes updated firmware.
    /// [br]Caliptra Access: RW
    /// [br]MCU Access:      RO
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::ResetRequestReadVal`]; Write value: [`mci_ctrl::regs::ResetRequestWriteVal`]
    #[inline(always)]
    pub fn reset_request(&self) -> ureg::RegRef<crate::mci_ctrl::meta::ResetRequest, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x100 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Used by MCU to acknowledge reset request by Caliptra for a firmware update.
    /// If RESET_REQUEST.req is set, a write by MCU to set the ack bit causes the MCU reset to assert.
    /// [br]Caliptra Access: RO
    /// [br]MCU Access:      RW
    /// [br]SOC Access:      RO
    ///
    /// Read value: [`mci_ctrl::regs::ResetAckReadVal`]; Write value: [`mci_ctrl::regs::ResetAckWriteVal`]
    #[inline(always)]
    pub fn reset_ack(&self) -> ureg::RegRef<crate::mci_ctrl::meta::ResetAck, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x104 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci_ctrl::regs::CaliptraBootGoReadVal`]; Write value: [`mci_ctrl::regs::CaliptraBootGoWriteVal`]
    #[inline(always)]
    pub fn caliptra_boot_go(&self) -> ureg::RegRef<crate::mci_ctrl::meta::CaliptraBootGo, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x108 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci_ctrl::regs::CaliptraAxiIdReadVal`]; Write value: [`mci_ctrl::regs::CaliptraAxiIdWriteVal`]
    #[inline(always)]
    pub fn caliptra_axi_id(&self) -> ureg::RegRef<crate::mci_ctrl::meta::CaliptraAxiId, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x10c / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Dynamic size assignment for the region of sram that contains executable instructions for MCU.
    ///
    /// Read value: [`mci_ctrl::regs::FwSramExecRegionSizeReadVal`]; Write value: [`mci_ctrl::regs::FwSramExecRegionSizeWriteVal`]
    #[inline(always)]
    pub fn fw_sram_exec_region_size(
        &self,
    ) -> ureg::RegRef<crate::mci_ctrl::meta::FwSramExecRegionSize, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x110 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Writable only by Caliptra, only when already at 0. (W1S, cleared only by MCU FW Update reset).
    /// [br]With a value of 0, only the Caliptra AXI ID is allowed to access the Updateable Execution SRAM region in the MCU.
    /// [br]Writing 1 to this register enables the MCU LSU and IFU AXI IDs to access the Updateable Execution SRAM Region.
    /// AXI IDs are provided as integration parameter/macro to MCU.
    /// Observing a value of 1 in this register (after exiting a reset) also indicates to MCU ROM that it may perform context switch to RT image.
    ///
    /// Read value: [`mci_ctrl::regs::LockReadVal`]; Write value: [`mci_ctrl::regs::LockWriteVal`]
    #[inline(always)]
    pub fn runtime_lock(&self) -> ureg::RegRef<crate::mci_ctrl::meta::RuntimeLock, &TMmio> {
        unsafe {
            ureg::RegRef::new_with_mmio(
                self.ptr.wrapping_add(0x114 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox0_valid_axi_id(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci_ctrl::meta::Mbox0ValidAxiId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x180 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci_ctrl::regs::LockReadVal`]; Write value: [`mci_ctrl::regs::LockWriteVal`]
    #[inline(always)]
    pub fn mbox0_valid_axi_id_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci_ctrl::meta::Mbox0ValidAxiIdLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1a0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn mbox1_valid_axi_id(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci_ctrl::meta::Mbox1ValidAxiId, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1c0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`mci_ctrl::regs::LockReadVal`]; Write value: [`mci_ctrl::regs::LockWriteVal`]
    #[inline(always)]
    pub fn mbox1_valid_axi_id_lock(
        &self,
    ) -> ureg::Array<5, ureg::RegRef<crate::mci_ctrl::meta::Mbox1ValidAxiIdLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x1e0 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn generic_input_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::GenericInputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x400 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn generic_output_wires(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::GenericOutputWires, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x408 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x410 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_s_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwSReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x418 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_cptra_rw_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdCptraRwReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x420 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_cptra_rw_s_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdCptraRwSReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x428 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_mcu_rw_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdMcuRwReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x430 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_mcu_rw_s_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdMcuRwSReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x438 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_l_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwLReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x440 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_l_reg_lock(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwLRegLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x448 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_l_s_reg(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwLSReg, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x450 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
    /// Set of reserved registers for survivability
    ///
    /// Read value: [`u32`]; Write value: [`u32`]
    #[inline(always)]
    pub fn rsvd_rw_l_s_reg_lock(
        &self,
    ) -> ureg::Array<2, ureg::RegRef<crate::mci_ctrl::meta::RsvdRwLSRegLock, &TMmio>> {
        unsafe {
            ureg::Array::new_with_mmio(
                self.ptr.wrapping_add(0x458 / core::mem::size_of::<u32>()),
                core::borrow::Borrow::borrow(&self.mmio),
            )
        }
    }
}
pub mod regs {
    //! Types that represent the values held by registers.
    #[derive(Clone, Copy, Default)]
    pub struct CaliptraAxiIdReadVal(u32);
    impl CaliptraAxiIdReadVal {
        #[inline(always)]
        pub fn id(&self) -> bool {
            (self.0 & 1) != 0
        }
    }
    impl From<u32> for CaliptraAxiIdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CaliptraAxiIdReadVal> for u32 {
        #[inline(always)]
        fn from(val: CaliptraAxiIdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct CaliptraBootGoReadVal(u32);
    impl CaliptraBootGoReadVal {
        /// fixme
        #[inline(always)]
        pub fn go(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CaliptraBootGoWriteVal {
            CaliptraBootGoWriteVal(self.0)
        }
    }
    impl From<u32> for CaliptraBootGoReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CaliptraBootGoReadVal> for u32 {
        #[inline(always)]
        fn from(val: CaliptraBootGoReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct CaliptraBootGoWriteVal(u32);
    impl CaliptraBootGoWriteVal {
        /// fixme
        #[inline(always)]
        pub fn go(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for CaliptraBootGoWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CaliptraBootGoWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CaliptraBootGoWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct CapabilitiesReadVal(u32);
    impl CapabilitiesReadVal {
        /// Number of Mailboxes in MCI
        #[inline(always)]
        pub fn num_mbox(&self) -> u32 {
            self.0 & 0xf
        }
    }
    impl From<u32> for CapabilitiesReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CapabilitiesReadVal> for u32 {
        #[inline(always)]
        fn from(val: CapabilitiesReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct CptraWdtStatusReadVal(u32);
    impl CptraWdtStatusReadVal {
        /// Timer1 timed out, timer2 enabled
        #[inline(always)]
        pub fn t1_timeout(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Timer2 timed out
        #[inline(always)]
        pub fn t2_timeout(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> CptraWdtStatusWriteVal {
            CptraWdtStatusWriteVal(self.0)
        }
    }
    impl From<u32> for CptraWdtStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct CptraWdtStatusWriteVal(u32);
    impl CptraWdtStatusWriteVal {
        /// Timer1 timed out, timer2 enabled
        #[inline(always)]
        pub fn t1_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
        /// Timer2 timed out
        #[inline(always)]
        pub fn t2_timeout(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for CptraWdtStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<CptraWdtStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: CptraWdtStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct FlowStatusReadVal(u32);
    impl FlowStatusReadVal {
        /// Generic Status
        #[inline(always)]
        pub fn status(&self) -> u32 {
            self.0 & 0xffffff
        }
        /// DEV ID CSR ready
        #[inline(always)]
        pub fn rsvd(&self) -> u32 {
            (self.0 >> 24) & 7
        }
        /// Boot FSM State
        #[inline(always)]
        pub fn boot_fsm_ps(&self) -> u32 {
            (self.0 >> 27) & 0x1f
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FlowStatusWriteVal {
            FlowStatusWriteVal(self.0)
        }
    }
    impl From<u32> for FlowStatusReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FlowStatusReadVal> for u32 {
        #[inline(always)]
        fn from(val: FlowStatusReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct FlowStatusWriteVal(u32);
    impl FlowStatusWriteVal {
        /// Generic Status
        #[inline(always)]
        pub fn status(self, val: u32) -> Self {
            Self((self.0 & !(0xffffff)) | (val & 0xffffff))
        }
    }
    impl From<u32> for FlowStatusWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FlowStatusWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FlowStatusWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct FwSramExecRegionSizeReadVal(u32);
    impl FwSramExecRegionSizeReadVal {
        /// Size (in multiples of 4KiB)
        #[inline(always)]
        pub fn size(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> FwSramExecRegionSizeWriteVal {
            FwSramExecRegionSizeWriteVal(self.0)
        }
    }
    impl From<u32> for FwSramExecRegionSizeReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwSramExecRegionSizeReadVal> for u32 {
        #[inline(always)]
        fn from(val: FwSramExecRegionSizeReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct FwSramExecRegionSizeWriteVal(u32);
    impl FwSramExecRegionSizeWriteVal {
        /// Size (in multiples of 4KiB)
        #[inline(always)]
        pub fn size(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for FwSramExecRegionSizeWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<FwSramExecRegionSizeWriteVal> for u32 {
        #[inline(always)]
        fn from(val: FwSramExecRegionSizeWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct HwErrorReadVal(u32);
    impl HwErrorReadVal {
        #[inline(always)]
        pub fn rsvd(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> HwErrorWriteVal {
            HwErrorWriteVal(self.0)
        }
    }
    impl From<u32> for HwErrorReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct HwErrorWriteVal(u32);
    impl HwErrorWriteVal {
        #[inline(always)]
        pub fn rsvd(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for HwErrorWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwErrorWriteVal> for u32 {
        #[inline(always)]
        fn from(val: HwErrorWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct HwRevIdReadVal(u32);
    impl HwRevIdReadVal {
        /// Official release version. Bit field encoding is:
        /// [br][lb]15:12[rb] Major version
        /// [br][lb]11: 8[rb] Minor version
        /// [br][lb] 7: 0[rb] Patch version
        #[inline(always)]
        pub fn mc_generation(&self) -> u32 {
            self.0 & 0xffff
        }
        #[inline(always)]
        pub fn soc_stepping_id(&self) -> u32 {
            (self.0 >> 16) & 0xffff
        }
    }
    impl From<u32> for HwRevIdReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<HwRevIdReadVal> for u32 {
        #[inline(always)]
        fn from(val: HwRevIdReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct ResetAckReadVal(u32);
    impl ResetAckReadVal {
        /// Ack. Writable by MCU. Causes MCU reset to assert (if RESET_REQUEST.req is also set)
        #[inline(always)]
        pub fn ack(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetAckWriteVal {
            ResetAckWriteVal(self.0)
        }
    }
    impl From<u32> for ResetAckReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetAckReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetAckReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct ResetAckWriteVal(u32);
    impl ResetAckWriteVal {
        /// Ack. Writable by MCU. Causes MCU reset to assert (if RESET_REQUEST.req is also set)
        #[inline(always)]
        pub fn ack(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for ResetAckWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetAckWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetAckWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct ResetReasonReadVal(u32);
    impl ResetReasonReadVal {
        /// FW update reset has been executed
        #[inline(always)]
        pub fn fw_upd_reset(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Warm reset has been executed
        #[inline(always)]
        pub fn warm_reset(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
    }
    impl From<u32> for ResetReasonReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetReasonReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetReasonReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct ResetRequestReadVal(u32);
    impl ResetRequestReadVal {
        /// Request. Writable by Caliptra. Causes MCU interrupt to assert.
        #[inline(always)]
        pub fn req(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Clear. Writable by Caliptra. On set, this bit autoclears, RESET_REQUEST.req clears, and MCU reset deasserts.
        #[inline(always)]
        pub fn clr(&self) -> bool {
            ((self.0 >> 1) & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> ResetRequestWriteVal {
            ResetRequestWriteVal(self.0)
        }
    }
    impl From<u32> for ResetRequestReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetRequestReadVal> for u32 {
        #[inline(always)]
        fn from(val: ResetRequestReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct ResetRequestWriteVal(u32);
    impl ResetRequestWriteVal {
        /// Request. Writable by Caliptra. Causes MCU interrupt to assert.
        #[inline(always)]
        pub fn req(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
        /// Clear. Writable by Caliptra. On set, this bit autoclears, RESET_REQUEST.req clears, and MCU reset deasserts.
        #[inline(always)]
        pub fn clr(self, val: bool) -> Self {
            Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
        }
    }
    impl From<u32> for ResetRequestWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<ResetRequestWriteVal> for u32 {
        #[inline(always)]
        fn from(val: ResetRequestWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer1CtrlReadVal(u32);
    impl WdtTimer1CtrlReadVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer1CtrlWriteVal {
            WdtTimer1CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer1CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer1CtrlWriteVal(u32);
    impl WdtTimer1CtrlWriteVal {
        /// WDT timer1 restart
        #[inline(always)]
        pub fn timer1_restart(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for WdtTimer1CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer1EnReadVal(u32);
    impl WdtTimer1EnReadVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer1EnWriteVal {
            WdtTimer1EnWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer1EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer1EnWriteVal(u32);
    impl WdtTimer1EnWriteVal {
        /// WDT timer1 enable
        #[inline(always)]
        pub fn timer1_en(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for WdtTimer1EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer1EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer1EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer2CtrlReadVal(u32);
    impl WdtTimer2CtrlReadVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer2CtrlWriteVal {
            WdtTimer2CtrlWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer2CtrlReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2CtrlReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2CtrlReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer2CtrlWriteVal(u32);
    impl WdtTimer2CtrlWriteVal {
        /// WDT timer2 restart
        #[inline(always)]
        pub fn timer2_restart(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for WdtTimer2CtrlWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2CtrlWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2CtrlWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer2EnReadVal(u32);
    impl WdtTimer2EnReadVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> WdtTimer2EnWriteVal {
            WdtTimer2EnWriteVal(self.0)
        }
    }
    impl From<u32> for WdtTimer2EnReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2EnReadVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2EnReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct WdtTimer2EnWriteVal(u32);
    impl WdtTimer2EnWriteVal {
        /// WDT timer2 enable
        #[inline(always)]
        pub fn timer2_en(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for WdtTimer2EnWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<WdtTimer2EnWriteVal> for u32 {
        #[inline(always)]
        fn from(val: WdtTimer2EnWriteVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct LockReadVal(u32);
    impl LockReadVal {
        #[inline(always)]
        pub fn lock(&self) -> bool {
            (self.0 & 1) != 0
        }
        /// Construct a WriteVal that can be used to modify the contents of this register value.
        #[inline(always)]
        pub fn modify(self) -> LockWriteVal {
            LockWriteVal(self.0)
        }
    }
    impl From<u32> for LockReadVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<LockReadVal> for u32 {
        #[inline(always)]
        fn from(val: LockReadVal) -> u32 {
            val.0
        }
    }
    #[derive(Clone, Copy, Default)]
    pub struct LockWriteVal(u32);
    impl LockWriteVal {
        #[inline(always)]
        pub fn lock(self, val: bool) -> Self {
            Self((self.0 & !(1)) | (u32::from(val)))
        }
    }
    impl From<u32> for LockWriteVal {
        #[inline(always)]
        fn from(val: u32) -> Self {
            Self(val)
        }
    }
    impl From<LockWriteVal> for u32 {
        #[inline(always)]
        fn from(val: LockWriteVal) -> u32 {
            val.0
        }
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub mod meta {
    //! Additional metadata needed by ureg.
    pub type Capabilities = ureg::ReadOnlyReg32<crate::mci_ctrl::regs::CapabilitiesReadVal>;
    pub type HwRevId = ureg::ReadOnlyReg32<crate::mci_ctrl::regs::HwRevIdReadVal>;
    pub type RomRevId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwRevId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type BootStatus = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FlowStatus = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::FlowStatusReadVal,
        crate::mci_ctrl::regs::FlowStatusWriteVal,
    >;
    pub type ResetReason = ureg::ReadOnlyReg32<crate::mci_ctrl::regs::ResetReasonReadVal>;
    pub type HwErrorFatal = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::HwErrorReadVal,
        crate::mci_ctrl::regs::HwErrorWriteVal,
    >;
    pub type HwErrorNonFatal = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::HwErrorReadVal,
        crate::mci_ctrl::regs::HwErrorWriteVal,
    >;
    pub type FwErrorFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type FwErrorNonFatal = ureg::ReadWriteReg32<0, u32, u32>;
    pub type WdtTimer1En = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::WdtTimer1EnReadVal,
        crate::mci_ctrl::regs::WdtTimer1EnWriteVal,
    >;
    pub type WdtTimer1Ctrl = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::WdtTimer1CtrlReadVal,
        crate::mci_ctrl::regs::WdtTimer1CtrlWriteVal,
    >;
    pub type WdtTimer1TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type WdtTimer2En = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::WdtTimer2EnReadVal,
        crate::mci_ctrl::regs::WdtTimer2EnWriteVal,
    >;
    pub type WdtTimer2Ctrl = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::WdtTimer2CtrlReadVal,
        crate::mci_ctrl::regs::WdtTimer2CtrlWriteVal,
    >;
    pub type WdtTimer2TimeoutPeriod = ureg::ReadWriteReg32<0xffffffff, u32, u32>;
    pub type CptraWdtStatus = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::CptraWdtStatusReadVal,
        crate::mci_ctrl::regs::CptraWdtStatusWriteVal,
    >;
    pub type WdtCfg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type McuTimerConfig = ureg::ReadWriteReg32<0, u32, u32>;
    #[derive(Clone, Copy)]
    pub struct McuClkGatingEn();
    impl ureg::RegType for McuClkGatingEn {
        type Raw = u32;
    }
    pub type ResetRequest = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::ResetRequestReadVal,
        crate::mci_ctrl::regs::ResetRequestWriteVal,
    >;
    pub type ResetAck = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::ResetAckReadVal,
        crate::mci_ctrl::regs::ResetAckWriteVal,
    >;
    pub type CaliptraBootGo = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::CaliptraBootGoReadVal,
        crate::mci_ctrl::regs::CaliptraBootGoWriteVal,
    >;
    pub type CaliptraAxiId = ureg::ReadOnlyReg32<crate::mci_ctrl::regs::CaliptraAxiIdReadVal>;
    pub type FwSramExecRegionSize = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::FwSramExecRegionSizeReadVal,
        crate::mci_ctrl::regs::FwSramExecRegionSizeWriteVal,
    >;
    pub type RuntimeLock = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::LockReadVal,
        crate::mci_ctrl::regs::LockWriteVal,
    >;
    pub type Mbox0ValidAxiId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Mbox0ValidAxiIdLock = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::LockReadVal,
        crate::mci_ctrl::regs::LockWriteVal,
    >;
    pub type Mbox1ValidAxiId = ureg::ReadWriteReg32<0, u32, u32>;
    pub type Mbox1ValidAxiIdLock = ureg::ReadWriteReg32<
        0,
        crate::mci_ctrl::regs::LockReadVal,
        crate::mci_ctrl::regs::LockWriteVal,
    >;
    pub type GenericInputWires = ureg::ReadOnlyReg32<u32>;
    pub type GenericOutputWires = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwSReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdCptraRwReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdCptraRwSReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdMcuRwReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdMcuRwSReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwLReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwLRegLock = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwLSReg = ureg::ReadWriteReg32<0, u32, u32>;
    pub type RsvdRwLSRegLock = ureg::ReadWriteReg32<0, u32, u32>;
}
