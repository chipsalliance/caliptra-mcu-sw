// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at fb99e5f5aadf5685badae3ea453e72b55be9328c
//
pub const AXICDMA_ADDR: u32 = 0xa408_1000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub AxicdmaBytesToTransfer [
                /// Bytes to transfer (bits [23:0], simple mode)
                Btt OFFSET(0) NUMBITS(24) [],
            ],
            pub AxicdmaControl [
                /// Reset DMA engine
                Reset OFFSET(2) NUMBITS(1) [],
                /// Scatter-gather mode enable
                Sgmode OFFSET(3) NUMBITS(1) [],
                /// Keyhole Read feature enable
                KholeRd OFFSET(4) NUMBITS(1) [],
                /// Keyhole Write feature enable
                KholeWr OFFSET(5) NUMBITS(1) [],
                ///  Complete Interrupt Enable. When set to 1, it allows CDMASR.IOC_Irq to generate an interrupt out for completed DMA transfers
                IocIrqEn OFFSET(12) NUMBITS(1) [],
                /// Error Interrupt Enable. When set to 1, it allows the CDMASR.Err_Irq to generate an interrupt out
                ErrIrqEn OFFSET(14) NUMBITS(1) [],
            ],
            pub AxicdmaStatus [
                /// DMA channel idle
                Idle OFFSET(1) NUMBITS(1) [],
                /// Hybrid (SG included) build
                Sgincld OFFSET(3) NUMBITS(1) [],
                /// Datamover internal error
                ErrInternal OFFSET(4) NUMBITS(1) [],
                /// Datamover slave error
                ErrSlave OFFSET(5) NUMBITS(1) [],
                /// Datamover decode error
                ErrDecode OFFSET(6) NUMBITS(1) [],
                /// Interrupt on completion
                IrqIoc OFFSET(12) NUMBITS(1) [],
                /// Error interrupt
                IrqError OFFSET(14) NUMBITS(1) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub Axicdma {
            (0x0 => pub axicdma_control: tock_registers::registers::ReadWrite<u32, crate::axicdma::bits::AxicdmaControl::Register>),
            (0x4 => pub axicdma_status: tock_registers::registers::ReadWrite<u32, crate::axicdma::bits::AxicdmaStatus::Register>),
            (0x8 => _reserved0),
            (0x18 => pub axicdma_src_addr: tock_registers::registers::ReadWrite<u32>),
            (0x1c => pub axicdma_src_addr_msb: tock_registers::registers::ReadWrite<u32>),
            (0x20 => pub axicdma_dst_addr: tock_registers::registers::ReadWrite<u32>),
            (0x24 => pub axicdma_dst_addr_msb: tock_registers::registers::ReadWrite<u32>),
            (0x28 => pub axicdma_bytes_to_transfer: tock_registers::registers::ReadWrite<u32, crate::axicdma::bits::AxicdmaBytesToTransfer::Register>),
            (0x2c => @END),
        }
    }
}
