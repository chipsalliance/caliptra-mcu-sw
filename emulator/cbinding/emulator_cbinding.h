#ifndef EMULATOR_CBINDING_H
#define EMULATOR_CBINDING_H

#pragma once

/* Generated with cbindgen:0.24.5 */

/*++

Licensed under the Apache-2.0 license.

Warning, this file is autogenerated by cbindgen. Don't modify this manually.

--*/


#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace  {
#endif // __cplusplus

/**
 * Step action results for C API
 */
typedef enum CStepAction {
    Continue = 0,
    Break = 1,
    ExitSuccess = 2,
    ExitFailure = 3,
} CStepAction;

/**
 * Error codes for C API
 */
typedef enum EmulatorError {
    Success = 0,
    InvalidArgs = -1,
    InitializationFailed = -2,
    NullPointer = -3,
    InvalidEmulator = -4,
} EmulatorError;

/**
 * Opaque structure representing the emulator
 * C code should allocate memory for this structure
 */
typedef struct CEmulator {
    uint8_t mPrivate[0];
} CEmulator;

/**
 * Configuration structure for emulator initialization
 *
 * Memory layout override parameters use int64_t values where:
 * - `-1` means use the default value
 * - Valid positive values (0 to UINT32_MAX) will be used as-is
 * - Invalid values (negative except -1, or > UINT32_MAX) will be treated as default
 *
 * Example usage in C:
 * ```c
 * CEmulatorConfig config = {
 *     .rom_path = "rom.bin",
 *     .firmware_path = "firmware.bin",
 *     // ... other required fields ...
 *     .rom_offset = 0x40000000,  // Use custom ROM offset
 *     .rom_size = -1,            // Use default ROM size
 *     .sram_offset = -1,         // Use default SRAM offset
 *     .sram_size = 0x100000,     // Use custom SRAM size (1MB)
 *     // ... other memory layout fields all set to -1 for defaults ...
 * };
 * ```
 */
typedef struct CEmulatorConfig {
    const char *mRomPath;
    const char *mFirmwarePath;
    const char *mCaliptraRomPath;
    const char *mCaliptraFirmwarePath;
    const char *mSocManifestPath;
    const char *mOtpPath;
    const char *mLogDirPath;
    unsigned int mGdbPort;
    unsigned int mI3cPort;
    unsigned char mTraceInstr;
    unsigned char mStdinUart;
    unsigned char mManufacturingMode;
    unsigned char mCaptureUartOutput;
    const char *mVendorPkHash;
    const char *mOwnerPkHash;
    const char *mStreamingBootPath;
    const char *mPrimaryFlashImagePath;
    const char *mSecondaryFlashImagePath;
    unsigned int mHwRevisionMajor;
    unsigned int mHwRevisionMinor;
    unsigned int mHwRevisionPatch;
    long long mRomOffset;
    long long mRomSize;
    long long mUartOffset;
    long long mUartSize;
    long long mCtrlOffset;
    long long mCtrlSize;
    long long mSpiOffset;
    long long mSpiSize;
    long long mSramOffset;
    long long mSramSize;
    long long mPicOffset;
    long long mExternalTestSramOffset;
    long long mExternalTestSramSize;
    long long mDccmOffset;
    long long mDccmSize;
    long long mI3cOffset;
    long long mI3cSize;
    long long mPrimaryFlashOffset;
    long long mPrimaryFlashSize;
    long long mSecondaryFlashOffset;
    long long mSecondaryFlashSize;
    long long mMciOffset;
    long long mMciSize;
    long long mDmaOffset;
    long long mDmaSize;
    long long mMboxOffset;
    long long mMboxSize;
    long long mSocOffset;
    long long mSocSize;
    long long mOtpOffset;
    long long mOtpSize;
    long long mLcOffset;
    long long mLcSize;
    const void *mExternalReadCallback;
    const void *mExternalWriteCallback;
    const void *mCallbackContext;
} CEmulatorConfig;

/**
 * C function pointer type for external read callbacks
 *
 * # Arguments
 * * `context` - Context pointer passed to the callback
 * * `size` - Size of the read operation (1, 2, or 4 bytes)
 * * `addr` - Address being read from
 * * `buffer` - Pointer to write the read data to
 *
 * # Returns
 * * 1 for success, 0 for failure
 */
typedef int (*CExternalReadCallback)(const void *context,
                                     unsigned int size,
                                     unsigned int addr,
                                     unsigned int *buffer);

/**
 * C function pointer type for external write callbacks
 *
 * # Arguments
 * * `context` - Context pointer passed to the callback
 * * `size` - Size of the write operation (1, 2, or 4 bytes)
 * * `addr` - Address being written to
 * * `data` - Data being written
 *
 * # Returns
 * * 1 for success, 0 for failure
 */
typedef int (*CExternalWriteCallback)(const void *context,
                                      unsigned int size,
                                      unsigned int addr,
                                      unsigned int data);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the size required to allocate memory for the emulator
 * This allows C code to allocate the right amount of memory
 */
size_t emulator_get_size(void);

/**
 * Get the alignment required for the emulator structure
 */
size_t emulator_get_alignment(void);

/**
 * Initialize an emulator in the provided memory location
 *
 * # Arguments
 * * `emulator_memory` - Pointer to allocated memory (must be at least emulator_get_size() bytes)
 * * `config` - Configuration for the emulator
 *
 * # Returns
 * * `EmulatorError::Success` on success
 * * Appropriate error code on failure
 *
 * # Safety
 * * `emulator_memory` must point to valid memory of at least `emulator_get_size()` bytes
 * * `emulator_memory` must be properly aligned (use `emulator_get_alignment()`)
 * * `config` must be a valid pointer to a CEmulatorConfig structure
 * * All string pointers in `config` must be valid null-terminated C strings
 */
enum EmulatorError emulator_init(struct CEmulator *aEmulatorMemory,
                                 const struct CEmulatorConfig *aConfig);

/**
 * Step the emulator once
 *
 * This function works in both normal and GDB modes:
 * - **Normal mode**: Steps the emulator directly
 * - **GDB mode**: Steps the underlying emulator, allowing C to control execution
 *   while GDB server is available for debugging/inspection
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Returns
 * * Step action result
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
enum CStepAction emulator_step(struct CEmulator *aEmulatorMemory);

/**
 * Destroy the emulator and clean up resources
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 * * After calling this function, the emulator memory should not be used
 */
void emulator_destroy(struct CEmulator *aEmulatorMemory);

/**
 * Get UART output if it was captured
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 * * `output_buffer` - Buffer to write the output to
 * * `buffer_size` - Size of the output buffer
 *
 * # Returns
 * * Number of bytes written to the buffer, or -1 if no output available
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 * * `output_buffer` must be a valid buffer of at least `buffer_size` bytes
 */
int emulator_get_uart_output(struct CEmulator *aEmulatorMemory,
                             char *aOutputBuffer,
                             size_t aBufferSize);

/**
 * Send a character to the emulator's UART RX (for console input simulation)
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 * * `character` - Character to send to UART RX
 *
 * # Returns
 * * 1 if character was queued successfully, 0 if UART RX buffer is full, -1 on error
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
int emulator_send_uart_char(struct CEmulator *aEmulatorMemory, char aCharacter);

/**
 * Check if UART RX is ready to accept a new character
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Returns
 * * 1 if UART RX is ready for input, 0 if busy/full, -1 on error
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
int emulator_uart_rx_ready(struct CEmulator *aEmulatorMemory);

/**
 * Get the most recent UART output (streaming mode)
 * This function returns only the new output since the last call and clears the buffer.
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 * * `output_buffer` - Buffer to write the output to
 * * `buffer_size` - Size of the output buffer
 *
 * # Returns
 * * Number of bytes written to the buffer, or -1 if no output available
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 * * `output_buffer` must be a valid buffer of at least `buffer_size` bytes
 */
int emulator_get_uart_output_streaming(struct CEmulator *aEmulatorMemory,
                                       char *aOutputBuffer,
                                       size_t aBufferSize);

/**
 * Start GDB server and wait for connection (blocking)
 * This function should only be called if the emulator was initialized with a GDB port.
 *
 * IMPORTANT: There are two ways to use GDB mode:
 *
 * 1. **GDB-controlled execution**: Call this function and let GDB control all stepping.
 *    The GDB server will handle all emulator execution and stepping commands.
 *    Do NOT call emulator_step() while this function is running.
 *
 * 2. **C-controlled execution with GDB debugging**: DON'T call this function.
 *    Instead, call emulator_step() normally to control execution from C.
 *    Connect GDB to the port and use GDB for debugging/inspection only.
 *    In this mode, GDB can inspect state but C controls when steps happen.
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator in GDB mode
 *
 * # Returns
 * * `EmulatorError::Success` when GDB session ends normally
 * * Appropriate error code on failure
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator in GDB mode
 */
enum EmulatorError emulator_run_gdb_server(struct CEmulator *aEmulatorMemory);

/**
 * Check if the emulator is in GDB mode
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Returns
 * * 1 if in GDB mode, 0 if in normal mode
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
int emulator_is_gdb_mode(struct CEmulator *aEmulatorMemory);

/**
 * Get the GDB port if the emulator is in GDB mode
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Returns
 * * GDB port number, or 0 if not in GDB mode
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
unsigned int emulator_get_gdb_port(struct CEmulator *aEmulatorMemory);

/**
 * Get the current program counter (PC) of the MCU CPU
 *
 * # Arguments
 * * `emulator_memory` - Pointer to the initialized emulator
 *
 * # Returns
 * * Current PC value of the MCU CPU
 *
 * # Safety
 * * `emulator_memory` must point to a valid, initialized emulator
 */
unsigned int emulator_get_pc(struct CEmulator *aEmulatorMemory);

/**
 * Trigger an exit request by setting EMULATOR_RUNNING to false
 * This will cause any loops waiting on EMULATOR_RUNNING to exit
 *
 * # Returns
 * * `EmulatorError::Success` on success
 */
enum EmulatorError emulator_trigger_exit(void);

/**
 * Example external read callback that returns the address as data
 * This is a simple test callback that C code can use for testing
 *
 * # Arguments
 * * `context` - Context pointer (unused in this example)
 * * `size` - Size of the read operation (1, 2, or 4 bytes)
 * * `addr` - Address being read from
 * * `buffer` - Pointer to write the read data to
 *
 * # Returns
 * * 1 for success
 *
 * # Safety
 * * `buffer` must be a valid pointer to a u32 that can be written to
 */
int example_external_read_callback(const void *aContext,
                                   unsigned int aSize,
                                   unsigned int aAddr,
                                   unsigned int *aBuffer);

/**
 * Example external write callback that logs the operation
 * This is a simple test callback that C code can use for testing
 *
 * # Arguments
 * * `context` - Context pointer (unused in this example)
 * * `size` - Size of the write operation (1, 2, or 4 bytes)
 * * `addr` - Address being written to
 * * `data` - Data being written
 *
 * # Returns
 * * 1 for success
 *
 * # Safety
 * * This function only reads the provided parameters and performs no unsafe operations
 * * All parameters are passed by value, so no pointer safety concerns
 */
int example_external_write_callback(const void *aContext,
                                    unsigned int aSize,
                                    unsigned int aAddr,
                                    unsigned int aData);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#ifdef __cplusplus
} // namespace 
#endif // __cplusplus

#endif /* EMULATOR_CBINDING_H */
